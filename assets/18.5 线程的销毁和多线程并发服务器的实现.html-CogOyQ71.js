import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,d as t,o as e}from"./app-y4S3ecjE.js";const n={};function h(l,i){return e(),s("div",null,[...i[0]||(i[0]=[t(`<h1 id="_18-5-线程的销毁和多线程并发服务器的实现" tabindex="-1"><a class="header-anchor" href="#_18-5-线程的销毁和多线程并发服务器的实现"><span>18.5 线程的销毁和多线程并发服务器的实现</span></a></h1><h2 id="销毁线程" tabindex="-1"><a class="header-anchor" href="#销毁线程"><span>销毁线程</span></a></h2><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Linux 线程并不是在首次调用的线程main函数返回时自动销毁，用以下方式加以明确，否则由线程创建的内存空间将一直存在。</p></div><p>这里线程main函数 就是线程函数<br> 明确销毁的方式：</p><ul><li>pthread_join( )</li><li>phtread_detach( )</li></ul><p><span style="background:#fff88f;">问：</span>线程的销毁 和 线程的终止的区别？<br> 终止：线程函数不会再被执行，线程的状态变为终止，但是线程本身仍然存在？<br> 销毁：线程相关的内存被清理，线程本身不再存在？</p><p>参考Gemini</p><table><thead><tr><th></th><th>终止</th><th>销毁</th></tr></thead><tbody><tr><td>何时</td><td>自己：pthread_exit( )，return<br>被动：pthread_cancel( ), exit( ), main - return</td><td>pthread_join( )：阻塞等待线程终止，获取返回值后销毁<br>pthread_detach( )：终止后由系统自动销毁</td></tr><tr><td>占用内存</td><td>“线程的栈空间、退出状态码。。。等资源仍然保留”</td><td>不占用任何内存 - 已经清理、销毁</td></tr></tbody></table><h3 id="detach" tabindex="-1"><a class="header-anchor" href="#detach"><span>detach</span></a></h3><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">NAME</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">       pthread_detach </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> detach a thread</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">SYNOPSIS</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">       #include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;pthread.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">       int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> pthread_detach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">pthread_t</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">       Compile </span><span style="--shiki-light:#A626A4;--shiki-dark:#ABB2BF;">and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> link with </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pthread.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">DESCRIPTION</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">       The</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  pthread_detach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() function marks the thread identified by thread as </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">detached</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.  </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">When</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a detached thread terminates, its resources are automatically released back to the system without the need </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> another thread to join with  the  terminated thread.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">		Attempting to detach an already detached thread results in unspecified behavior.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>&quot;调用该函数不会引起（指定的）线程终止 或 （导致调用该函数的线程）进入阻塞状态 &quot;</li><li>不能对已经detach的线程再次调用 pthread_join</li></ul><p><span style="background:#fff88f;">问：</span>对于调用detach 时已经终止 和 尚未终止的线程，系统是如何进行回收的？</p><h2 id="多线程并发服务器端的实现" tabindex="-1"><a class="header-anchor" href="#多线程并发服务器端的实现"><span>多线程并发服务器端的实现</span></a></h2><p>略</p>`,14)])])}const r=a(n,[["render",h]]),c=JSON.parse('{"path":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/18.5%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%94%80%E6%AF%81%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0.html","title":"18.5 线程的销毁和多线程并发服务器的实现","lang":"zh-CN","frontmatter":{"category":"网络编程","description":"18.5 线程的销毁和多线程并发服务器的实现 销毁线程 相关信息 Linux 线程并不是在首次调用的线程main函数返回时自动销毁，用以下方式加以明确，否则由线程创建的内存空间将一直存在。 这里线程main函数 就是线程函数 明确销毁的方式： pthread_join( ) phtread_detach( ) 问：线程的销毁 和 线程的终止的区别？ 终...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"18.5 线程的销毁和多线程并发服务器的实现\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-01-28T13:23:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"mingStudent\\"}]}"],["meta",{"property":"og:url","content":"https://guzhoutingxue.github.io/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/18.5%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%94%80%E6%AF%81%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0.html"}],["meta",{"property":"og:title","content":"18.5 线程的销毁和多线程并发服务器的实现"}],["meta",{"property":"og:description","content":"18.5 线程的销毁和多线程并发服务器的实现 销毁线程 相关信息 Linux 线程并不是在首次调用的线程main函数返回时自动销毁，用以下方式加以明确，否则由线程创建的内存空间将一直存在。 这里线程main函数 就是线程函数 明确销毁的方式： pthread_join( ) phtread_detach( ) 问：线程的销毁 和 线程的终止的区别？ 终..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-28T13:23:03.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-28T13:23:03.000Z"}]]},"git":{"createdTime":1769606583000,"updatedTime":1769606583000,"contributors":[{"name":"guZhouTingXue","username":"guZhouTingXue","email":"2422173022@qq.com","commits":1,"url":"https://github.com/guZhouTingXue"}]},"readingTime":{"minutes":1.39,"words":417},"filePathRelative":"网络编程/18.5 线程的销毁和多线程并发服务器的实现.md","excerpt":"","autoDesc":true}');export{r as comp,c as data};
