import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as a,o as e}from"./app-iO2jZn-u.js";const n={};function l(h,i){return e(),t("div",null,i[0]||(i[0]=[a(`<h1 id="_10-3-1-passing-a-function-to-an-algorithm" tabindex="-1"><a class="header-anchor" href="#_10-3-1-passing-a-function-to-an-algorithm"><span>10.3.1 Passing a Function to an Algorithm</span></a></h1><ul><li>Predicates</li><li>Sorting Algorithms</li></ul><p>在顺序容器中存放有多个按照首字母排序的字符串，现在要求：</p><ol><li>先按照单词的长度由小到大进行排列（第一个元素长度最小）</li><li>对于长度相同的单词，再按照其字母顺序排列</li></ol><p>排序的对象：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    vector</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">string</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> words </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;fox&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;jumps&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;over&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;quick&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">                            &quot;red&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;slow&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;the&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;turtle&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="predicates" tabindex="-1"><a class="header-anchor" href="#predicates"><span>Predicates</span></a></h2><blockquote><p>[!quote]<br> A predicate is an expression that can be called and that returns a value that can be used as a condition. The predicates used by library algorithms are either unary predicates (meaning they have a single parameter) or binary predicates (meaning they have two parameters).</p></blockquote><ul><li>can be called：可调用对象</li><li>returns value 。。 condition：返回的值可以被转换为bool值</li><li>library 中只有两种predicate：unary - 有1个参数；binary - 有两个参数</li><li>算法将element 当作predicate 的参数，通过predicate 的返回值进行判断。</li><li>由于算法传递element 给 predicate，所以要求element 的类型能够转换为predicate 的参数类型</li></ul><p>使用排序算法比较字符串长度的predicate：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">bool</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> isShorter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> string</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">s1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> string</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">s2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> s1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> s2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="sorting-algorithms" tabindex="-1"><a class="header-anchor" href="#sorting-algorithms"><span>Sorting Algorithms</span></a></h2><p>algorithms 与 使用的 predicate 类型表：</p><table><thead><tr><th>algorithm</th><th>参数</th><th>predicate</th><th>功能</th></tr></thead><tbody><tr><td>InputIt find_if</td><td>( InputIt first, InputIt last, UnaryPred p )</td><td>unary</td><td><code>find_if</code> searches for an element for which predicate p returns true.<br>返回使得predicate p 为真的元素的iterator</td></tr><tr><td>void stable_sort</td><td>( RandomIt first, RandomIt last, Compare comp );</td><td>binary</td><td>Sorts the elements in the range <code>[</code>first<code>,</code> last<code>)</code> in non-descending order. The order of equivalent elements is guaranteed to be preserved.<br>按照不小于的顺序进行排列，对于相等值的元素，保持原有顺序</td></tr><tr><td>void sort</td><td>( RandomIt first, RandomIt last, Compare comp );</td><td>binary</td><td>sort 也是按照 non-descending 的顺序排序，但是和stable_sort相比，它不保证相等值元素的顺序和排列前相同</td></tr></tbody></table><p>因为words 已经是按照首字母顺序进行排列的了，所以只需要通过stable_sort（）对其按照长度排序，相同长度的word 保持原有顺序（字母排列）。<br> 实现：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">stable_sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">words</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">begin</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">words</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">end</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), isShorter);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> auto</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">w : words)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> w </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot; &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> endl;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果：</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="output"><span>output</span></div><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-txt"><span class="line"><span>fox red the over slow jumps quick turtle</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></div>`,18)]))}const d=s(n,[["render",l]]),k=JSON.parse('{"path":"/C__%20Primer/10.3.1%20Passing%20a%20Function%20to%20an%20Algorithm.html","title":"10.3.1 Passing a Function to an Algorithm","lang":"zh-CN","frontmatter":{"category":"C++Primer","description":"10.3.1 Passing a Function to an Algorithm Predicates Sorting Algorithms 在顺序容器中存放有多个按照首字母排序的字符串，现在要求： 先按照单词的长度由小到大进行排列（第一个元素长度最小） 对于长度相同的单词，再按照其字母顺序排列 排序的对象： Predicates [!quote] ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"10.3.1 Passing a Function to an Algorithm\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-22T11:06:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"mingStudent\\"}]}"],["meta",{"property":"og:url","content":"https://guzhoutingxue.github.io/C__%20Primer/10.3.1%20Passing%20a%20Function%20to%20an%20Algorithm.html"}],["meta",{"property":"og:title","content":"10.3.1 Passing a Function to an Algorithm"}],["meta",{"property":"og:description","content":"10.3.1 Passing a Function to an Algorithm Predicates Sorting Algorithms 在顺序容器中存放有多个按照首字母排序的字符串，现在要求： 先按照单词的长度由小到大进行排列（第一个元素长度最小） 对于长度相同的单词，再按照其字母顺序排列 排序的对象： Predicates [!quote] ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-22T11:06:43.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-22T11:06:43.000Z"}]]},"git":{"createdTime":1758539203000,"updatedTime":1758539203000,"contributors":[{"name":"guZhouTingXue","username":"guZhouTingXue","email":"2422173022@qq.com","commits":1,"url":"https://github.com/guZhouTingXue"}]},"readingTime":{"minutes":1.68,"words":503},"filePathRelative":"C++ Primer/10.3.1 Passing a Function to an Algorithm.md","excerpt":"","autoDesc":true}');export{d as comp,k as data};
