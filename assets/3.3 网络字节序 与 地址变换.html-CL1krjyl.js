import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as t,b as n,d as l,e as s,o as h}from"./app-CSsYFWXD.js";const r="/assets/3.3%20%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%20%E4%B8%8E%20%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2-BmEemlv3.webp",d="/assets/3.3%20%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%20%E4%B8%8E%20%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2-1-QsEqx744.webp",p={};function o(k,i){return h(),e("div",null,[i[0]||(i[0]=t("h1",{id:"_3-3-网络字节序-与-地址变换",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#_3-3-网络字节序-与-地址变换"},[t("span",null,"3.3 网络字节序 与 地址变换")])],-1)),i[1]||(i[1]=t("blockquote",null,[t("p",null,[s("[!quote]"),t("br"),s(" 不同CPU中，数据在内存空间中的保存方式不同。")])],-1)),n(" more "),i[2]||(i[2]=l('<h2 id="字节序-与-网络字节序" tabindex="-1"><a class="header-anchor" href="#字节序-与-网络字节序"><span>字节序 与 网络字节序</span></a></h2><p>十六进制值0x12345678在内存中的存储长度为4字节，0x12为高位字节，0x78为低位字节<br> 假设内存地址0x20~0x23存储该值<br> 存储有两种方式：<br> 大端（Big Endian）：高位字节（0x12）存放在低位地址（0x20）；低位字节存放在高位地址<br> 小端（Little Endian）：高位字节（0x12）存放在高位地址（0x23）；低位字节存放在低位地址</p><table><thead><tr><th>内存地址</th><th>值（小）</th><th>大端</th></tr></thead><tbody><tr><td>0x23</td><td>0x12</td><td>0x78</td></tr><tr><td>0x22</td><td>0x34</td><td>0x56</td></tr><tr><td>0x21</td><td>0x56</td><td>0x34</td></tr><tr><td>0x20</td><td>0x78</td><td>0x12</td></tr></tbody></table><p>按照地址顺序从低到高，按照大端字节序排序的数据和正常书写顺序相同，小端相反。小端存放的数据访问字节更方便。如向下转型，直接取低位字节。使用大端，进行转型，需要取高位字节。CPU运算是从低位地址开始的，和小端存储数据顺序相同。</p><p>主流的Intel系列CPU按小端字节序存储数据。</p><h3 id="网络字节序" tabindex="-1"><a class="header-anchor" href="#网络字节序"><span>网络字节序</span></a></h3><ul><li>发送数据从保存在低位地址的数据开始传输</li><li>接收数据从低位地址开始存储</li></ul><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>字节序不同的计算机之间进行通信，接收方接收后解析值和发送值不同。</p><p>问：<mark style="background:#FFF3A3A6;">书中图示中大端系统是从低地址开始传输，并从低地址开始存储，小端系统是否相同？</mark><br> 从结果看是这样的，小端系统解析为0x3412，所以低字节0x12存放在低地址。而0x12是先接收的，所以是从低地址向高地址存储。</p><p>问：<mark style="background:#FFF3A3A6;">网络传输数据是逐字节传输？</mark><br> 传输0x1234，两字节数据，但是数据是单个单个字节传输</p><blockquote><p>[!quote]<br> 在通过网络传输数据时约定统一方式，这种约定称为网络字节序。统一为大端序。即，先把数据数组转化成大端序格式再进行网络传输。</p></blockquote><ul><li>传输前将数据转换为大端序：先传输低地址内存数据，将高字节数据放到低地址内存</li><li>接收时是大端序接收：从MSB-最高有效字节开始接收，到LSB-最低有效字节结束</li></ul><figure><img src="'+d+`" alt="|600x367" tabindex="0" loading="lazy"><figcaption>|600x367</figcaption></figure><p>问：<mark style="background:#FFF3A3A6;">小端系统按大端序接收时，是否还是按照从低地址到高地址接收，然后再转换。还是改变接收方式：从高地址到低地址接收？</mark></p><p>问：<mark style="background:#FFF3A3A6;">小端系统按照大端序发送时，是否将数据拷贝一份后转换为大端序，然后从低地址到高地址发送。还是直接从高地址到低地址传输？</mark></p><p>问题的关键在于传输、接收的方式是否相同且不会发生改变：从低地址到高地址开始传输，从低地址到高地址开始接收。<br> 从上图中开起来改变接收方式的方法比较简单。如果接收方式不变，网络传输的是字节流，对于两个十六进制数：0x1234、0x5678，接收后如何判断改变顺序的范围？调换0x12、0x34的顺序，而不是0x12、0x34、0x56、0x78 的顺序？</p><h2 id="字节序转换" tabindex="-1"><a class="header-anchor" href="#字节序转换"><span>字节序转换</span></a></h2><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//port</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> short</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> htons</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unsigned</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> short</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> short</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ntohs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unsigned</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> short</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//address  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> htonl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unsigned</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ntohl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unsigned</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>行号</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>2</td><td>用于端口的字节序转换，主机序转换为网络序</td><td>h host：主机；n network：网络； s：short</td></tr><tr><td>6-7</td><td>用于地址的转换</td><td></td></tr></tbody></table><div class="hint-container note"><p class="hint-container-title">注</p><p>除了向sockaddr_in 结构体变量填充数据外，其他情况无需考虑字节序问题</p></div><p>补充：以及从sockaddr_in 结构体获取 网络字节序的地址 和 端口号</p>`,22))])}const A=a(p,[["render",o]]),u=JSON.parse('{"path":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/3.3%20%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%20%E4%B8%8E%20%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.html","title":"3.3 网络字节序 与 地址变换","lang":"zh-CN","frontmatter":{"category":"网络编程","description":"[!quote] 不同CPU中，数据在内存空间中的保存方式不同。","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"3.3 网络字节序 与 地址变换\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-05T14:57:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"mingStudent\\"}]}"],["meta",{"property":"og:url","content":"https://guzhoutingxue.github.io/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/3.3%20%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%20%E4%B8%8E%20%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.html"}],["meta",{"property":"og:title","content":"3.3 网络字节序 与 地址变换"}],["meta",{"property":"og:description","content":"[!quote] 不同CPU中，数据在内存空间中的保存方式不同。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-05T14:57:08.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-05T14:57:08.000Z"}]]},"git":{"createdTime":1759412253000,"updatedTime":1759676228000,"contributors":[{"name":"guZhouTingXue","username":"guZhouTingXue","email":"2422173022@qq.com","commits":2,"url":"https://github.com/guZhouTingXue"}]},"readingTime":{"minutes":3.35,"words":1004},"filePathRelative":"网络编程/3.3 网络字节序 与 地址变换.md","excerpt":"\\n<blockquote>\\n<p>[!quote]<br>\\n不同CPU中，数据在内存空间中的保存方式不同。</p>\\n</blockquote>\\n","autoDesc":true}');export{A as comp,u as data};
