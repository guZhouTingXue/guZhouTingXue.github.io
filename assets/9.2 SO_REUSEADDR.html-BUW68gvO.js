import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as h,d as l,f as t,w as i,r,o as c,e as p}from"./app-BCPEZZTD.js";const k={};function u(m,s){const n=r("Mermaid"),d=r("Tabs");return c(),h("div",null,[s[2]||(s[2]=l(`<h1 id="_9-2-so-reuseaddr" tabindex="-1"><a class="header-anchor" href="#_9-2-so-reuseaddr"><span>9.2 SO_REUSEADDR</span></a></h1><p>该选项的作用：“Allow reuse of local addresses&quot;</p><h2 id="发生地址分配错误" tabindex="-1"><a class="header-anchor" href="#发生地址分配错误"><span>发生地址分配错误</span></a></h2><p>服务器通过 <code>ctrl + c</code> 关闭程序，然后立即再次启动服务器，程序会报错。<br> 执行情况：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>ming@ubuntu:/media/sf_share/Network/build$ ./Network 192.168.56.101 10086</span></span>
<span class="line"><span>^C</span></span>
<span class="line"><span>ming@ubuntu:/media/sf_share/Network/build$ ./Network 192.168.56.101 10086</span></span>
<span class="line"><span>bind() error: Address already in use</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>错误信息显示 <strong>Address already in use</strong></p><h2 id="time-wait-状态" tabindex="-1"><a class="header-anchor" href="#time-wait-状态"><span>Time-wait 状态</span></a></h2>`,7)),t(d,{data:[{id:"正常断开连接"},{id:"被断开一方未收到ACK"}]},{title0:i(({value:e,isActive:a})=>[...s[0]||(s[0]=[p("正常断开连接",-1)])]),title1:i(({value:e,isActive:a})=>[...s[1]||(s[1]=[p("被断开一方未收到ACK",-1)])]),tab0:i(({value:e,isActive:a})=>[t(n,{code:"eJwrTi0sTc1LTnXJTEwvSszl4ipILCrJTM4sSMwrUXiyY/ezObscsYg5cXFBJRV07exgglYKbp5+UAknJAlHKwVHZ2/sEkAdOghJNONAEn75JakKRZnpGSUK+WkIqWfbOl7OXFKcn5ydWsKVmFySWZYIVAdzMVhTTmoakh6gXSGZuam65YmZJVhsA0q/WLfw2fRtz3dPfjZ3PldKKpGGojgEADePnUU="})]),tab1:i(({value:e,isActive:a})=>[t(n,{code:"eJwrTi0sTc1LTnXJTEwvSszl4ipILCrJTM4sSMwrUXBUSCxWeLJj97M5uxxRJJwQEk5cXI4KunZ2Ck5WCm6eflxOYI6jlYKjszeCA5TRAQnAlYI4icklmWWJJakKjlx++UAqJzWtRCE/DaQ+JDM3Vbc8MbMEIpNflloE0hWh8GzOqmdTtj3t2IBuPNRoIOfFuoXPpm972tb6tK332ZqFT/unA5WDVKSkItmI4hKwJUWZ6Rlg+4GCz7Z1vJy5pDg/OTu1BJ87X7b3Ppu24emE9U+7VkDsRXfH892Tn82dj2o3uikotgEAthOYGg=="})]),_:1}),s[3]||(s[3]=l(`<p>正常情况下，发起断开连接（先发送FIN的）的主机A，在发送完对主机B的 FIN 的 ACK 后会进入Time-wait 状态。这个状态是为了确保主机B收到了 FIN 的 ACK 响应，如果在计时段内 A 再次收到 B的FIN 说明 B 未收到 ACK，A 重新发送 ACK，并重置计时器。断开发起方A在计时器条件满足后消除socket。</p><p>如果关闭服务器后立即再次启动服务器，尝试绑定之前的端口。由于存在Time-wait 状态，此时前面的socket 还没有消除，端口被占用，所以无法绑定socket。</p><div class="hint-container note"><p class="hint-container-title">注</p><p>发起断开连接的socket 存在 Time-wait 状态。如果由客户端发起断开连接，客户端socket 也会存在 Time-wait 状态，只不过客户端socket 的端口通常是随机分配，再次连接服务器时 使用另外的端口，所以没有影响。</p></div><h2 id="地址再分配" tabindex="-1"><a class="header-anchor" href="#地址再分配"><span>地址再分配</span></a></h2><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>调整 SO_REUSEADDR 参数，可将 Time-wait 状态下的套接字端口号重新分配给新的套接字.<br> SO_REUSEADDR 的默认值为0</p></div><p>问：<span style="background:#fff88f;">重新分配后创建新的socket C，那么原来的socket - A 如何？是不存在 Time-wait 了，还是Time-wait 的职责被 C 继承了？又或者系统记录了状态，不影响原有的socket，Time-wait 功能正常（B的FIN 仍会发送给A），系统会清理 A？</span></p><p>参考AI：</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>SO_REUSEADDR 允许你重新 bind 端口，但原来的 TIME-WAIT 连接仍然是独立存在的 TCP 控制块，继续完成 TIME-WAIT 的全部职责，直到内核自动清除。</p></div><p>实现：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> option </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">    socklen_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> optlen </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(option);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    setsockopt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(sock, SOL_SOCKET, SO_REUSEADDR, (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">option, optlen);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>ming@ubuntu:/media/sf_share/Network/build$ ./Network 192.168.56.101 10086</span></span>
<span class="line"><span>^C</span></span>
<span class="line"><span>ming@ubuntu:/media/sf_share/Network/build$ ./Network 192.168.56.101 10086</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以直接绑定</p>`,13))])}const b=o(k,[["render",u]]),v=JSON.parse('{"path":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/9.2%20SO_REUSEADDR.html","title":"9.2 SO_REUSEADDR","lang":"zh-CN","frontmatter":{"category":"网络编程","description":"9.2 SO_REUSEADDR 该选项的作用：“Allow reuse of local addresses\\" 发生地址分配错误 服务器通过 ctrl + c 关闭程序，然后立即再次启动服务器，程序会报错。 执行情况： 错误信息显示 Address already in use Time-wait 状态 正常情况下，发起断开连接（先发送FIN的）的主...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"9.2 SO_REUSEADDR\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-29T14:04:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"mingStudent\\"}]}"],["meta",{"property":"og:url","content":"https://guzhoutingxue.github.io/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/9.2%20SO_REUSEADDR.html"}],["meta",{"property":"og:title","content":"9.2 SO_REUSEADDR"}],["meta",{"property":"og:description","content":"9.2 SO_REUSEADDR 该选项的作用：“Allow reuse of local addresses\\" 发生地址分配错误 服务器通过 ctrl + c 关闭程序，然后立即再次启动服务器，程序会报错。 执行情况： 错误信息显示 Address already in use Time-wait 状态 正常情况下，发起断开连接（先发送FIN的）的主..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-29T14:04:22.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-29T14:04:22.000Z"}]]},"git":{"createdTime":1764425062000,"updatedTime":1764425062000,"contributors":[{"name":"guZhouTingXue","username":"guZhouTingXue","email":"2422173022@qq.com","commits":1,"url":"https://github.com/guZhouTingXue"}]},"readingTime":{"minutes":2.48,"words":744},"filePathRelative":"网络编程/9.2 SO_REUSEADDR.md","excerpt":"","autoDesc":true}');export{b as comp,v as data};
