import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as a,o as e}from"./app-PlJrQRNa.js";const n={};function l(h,i){return e(),t("div",null,i[0]||(i[0]=[a(`<h1 id="_2-套接字类型与协议设置" tabindex="-1"><a class="header-anchor" href="#_2-套接字类型与协议设置"><span>2. 套接字类型与协议设置</span></a></h1><blockquote><p>[!quote]<br> 协议就是为了完成数据交换而定好的约定</p></blockquote><h2 id="创建套接字" tabindex="-1"><a class="header-anchor" href="#创建套接字"><span>创建套接字</span></a></h2><blockquote><p>[!quote]<br> create an endpoint for communication</p></blockquote><p>命令： man 2 socket</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;sys/types.h&gt;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">          /* See NOTES */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;sys/socket.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> domain</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> protocol</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="domain" tabindex="-1"><a class="header-anchor" href="#domain"><span>domain</span></a></h3><blockquote><p>[!quote]<br> this selects the protocol family which will be used for communication.</p></blockquote><table><thead><tr><th>Name</th><th>Purpose</th><th>地址示例</th><th>用途</th><th>说明</th></tr></thead><tbody><tr><td>AF_INET</td><td>IPv4互联网协议族</td><td>10.0.2.15</td><td></td><td></td></tr><tr><td>AF_INET6</td><td>IPv6</td><td>fe80::5506:f276:a82b:aab6%20</td><td></td><td></td></tr><tr><td>AF_LOCAL, AF_UNIX</td><td>Local communication</td><td>/tmp/mysocket</td><td>本地进程间通信</td><td></td></tr><tr><td>AF_PACKET</td><td>Low level packet interface</td><td>00:22:15:56:0b:54<br>网卡mac 地址，windows 可以在powershell 中使用getmac 查看。linux 使用ifconfig命令，HWaddr 08:00:27:fe:8b:f8</td><td>抓包工具</td><td>linxu特有，以获取到所有经过数据链路层的帧</td></tr></tbody></table><p>使用Winpacp、Npacp 抓包是通过驱动提供的接口获取到帧。</p><h3 id="关于af-与-pf" tabindex="-1"><a class="header-anchor" href="#关于af-与-pf"><span>关于AF 与 PF</span></a></h3><p>书中名称为PF（protocol family），使用man 查看帮助中的参数名称AF（address family）<br> 两者值是一样的<br> 使用AF，在表现上是通过地址进行区分。</p><h3 id="type" tabindex="-1"><a class="header-anchor" href="#type"><span>type</span></a></h3><blockquote><p>[!quote]<br> specifies the communication semantics</p></blockquote><table><thead><tr><th>Name</th><th>Purpose</th></tr></thead><tbody><tr><td>SOCK_STREAM</td><td>Provides sequenced, reliable, two-way, connection-based byte streams.</td></tr><tr><td>SOCK_DGRAM</td><td>Supports datagrams (connectionless, unreliable message of a fixed maximum length)</td></tr><tr><td>SOCK_RAW</td><td>Provides raw network protocol access</td></tr></tbody></table><h4 id="面向连接的套接字-sock-stream" tabindex="-1"><a class="header-anchor" href="#面向连接的套接字-sock-stream"><span>面向连接的套接字 SOCK_STREAM</span></a></h4><p>特点：</p><ul><li>sequence： 数据带有序号；接收顺序和发送顺序一致</li><li>reliable：数据内容不会出错</li><li>two-way：双向通讯，客户端、服务端都可以同时发送、接收数据</li><li>connection based：通讯前需要先连接连接；一对一进行通讯</li><li>byte streams：字节流。不存在数据边界（Boundary）</li></ul><p>byte streams 的具体含义：<br> 发送方多次发送的数据，接收方可以1字节1字节读取，也可以2字节，3字节。。<br> 接收方没办法根据读取到的字节数量（也相当于读取次数）判断是否接收了多少到了多少包以及包时候完整。<br> 在接收方看来，包与包之间没有间隔（没有数据边界）<br> 需要自己定义报文的分割方式。<br> 流：流动、连续</p><h5 id="缓冲区" tabindex="-1"><a class="header-anchor" href="#缓冲区"><span>缓冲区</span></a></h5><p>socket 内有接收、发送缓冲（字节数组）</p><blockquote><p>[!quote]<br> 接收缓冲区满时，传输端套接字将停止传输。面向连接的套接字会根据接收端的状态传输数据。</p></blockquote><h4 id="面向消息的套接字-sock-dgram" tabindex="-1"><a class="header-anchor" href="#面向消息的套接字-sock-dgram"><span>面向消息的套接字 SOCK_DGRAM</span></a></h4><p>特点：</p><ul><li>connectionless： 不需要建立连接，直接发送、接收数据</li><li>unreliable: 不可靠。可能发生数据丢失、出错、重复。发送的顺序和接收的顺序不一致。</li><li>fixed maximum length：固定的最大长度。限制单条数据报的最大长度。每次<mark style="background:#FFB8EBA6;">发送</mark>的数据是一个完整的数据报（datagram）</li><li>传输速度快</li></ul><h3 id="protocol" tabindex="-1"><a class="header-anchor" href="#protocol"><span>protocol</span></a></h3><blockquote><p>[!quote]<br> The protocol specifies a particular protocol to be used with the socket.</p></blockquote><table><thead><tr><th>domain</th><th>type</th><th>protocol</th></tr></thead><tbody><tr><td>AF_INET</td><td>SOCK_STREAM</td><td>IPPROTO_TCP</td></tr><tr><td>AF_INET</td><td>SOCK_DGRAM</td><td>IPPROTO_UDP</td></tr><tr><td>AF_INET</td><td>SOCK_RAW</td><td>IPPROTO_ICMP, IPPROTO_IGMP...</td></tr></tbody></table><p>通常通过domain 和 type 即可确定protocol，但是如果有多个protocol可用时需要protocol参数指定使用的protocol<br> 唯一确定时protocol 使用0</p><h2 id="测试tcp-的-无数据边界特性" tabindex="-1"><a class="header-anchor" href="#测试tcp-的-无数据边界特性"><span>测试TCP 的 无数据边界特性</span></a></h2><p>服务端一次发送13字节数据，客户端read读取单个字节，应该调用13次read。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(read_len </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(sock, </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">message</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[idx</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">], </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	{</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		//printf(&quot;read_len:%d\\n&quot;, read_len);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">		if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(read_len </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">			unix_error</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;read() error!&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">		str_len </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> read_len;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	}</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;read_len:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, read_len);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Message from server :</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%s</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, message);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Function read call count: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, str_len);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>read_len:0</span></span>
<span class="line"><span>Message from server :Hello World!</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Function read call count: 13</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用网络调试助手，在client 连接成功后，服务端发送数据。然后关闭服务端，client read返回0.<br> 如果不关闭服务端，那么read阻塞，一直等待数据。</p><h2 id="练习" tabindex="-1"><a class="header-anchor" href="#练习"><span>练习</span></a></h2><h3 id="_6-多次发送一次读取" tabindex="-1"><a class="header-anchor" href="#_6-多次发送一次读取"><span>6：多次发送一次读取</span></a></h3><p>在server中多次发送数据，client 一次性读取到全部数据。<br> 验证：多包数据可能在传输前合并为一包数据<br> 提示server中每次write 后 执行多余操作（printf）进行延时</p>`,38)]))}const p=s(n,[["render",l]]),o=JSON.parse('{"path":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2.%20%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E8%AE%BE%E7%BD%AE.html","title":"2. 套接字类型与协议设置","lang":"zh-CN","frontmatter":{"category":"网络编程","description":"2. 套接字类型与协议设置 [!quote] 协议就是为了完成数据交换而定好的约定 创建套接字 [!quote] create an endpoint for communication 命令： man 2 socket domain [!quote] this selects the protocol family which will be use...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2. 套接字类型与协议设置\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-17T13:44:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"mingStudent\\"}]}"],["meta",{"property":"og:url","content":"https://guzhoutingxue.github.io/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2.%20%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E8%AE%BE%E7%BD%AE.html"}],["meta",{"property":"og:title","content":"2. 套接字类型与协议设置"}],["meta",{"property":"og:description","content":"2. 套接字类型与协议设置 [!quote] 协议就是为了完成数据交换而定好的约定 创建套接字 [!quote] create an endpoint for communication 命令： man 2 socket domain [!quote] this selects the protocol family which will be use..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-17T13:44:49.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-17T13:44:49.000Z"}]]},"git":{"createdTime":1758116689000,"updatedTime":1758116689000,"contributors":[{"name":"guZhouTingXue","username":"guZhouTingXue","email":"2422173022@qq.com","commits":1,"url":"https://github.com/guZhouTingXue"}]},"readingTime":{"minutes":3.19,"words":957},"filePathRelative":"网络编程/2. 套接字类型与协议设置.md","excerpt":"","autoDesc":true}');export{p as comp,o as data};
