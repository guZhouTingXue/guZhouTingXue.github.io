import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as i,f as s,w as n,r as p,o as h,a as t,e as u}from"./app-CGqIYa7W.js";const m="/assets/4.1%20%E7%90%86%E8%A7%A3TCP%20%E5%92%8C%20UDP-C1eqGZtZ.webp",c={};function P(b,l){const r=p("Tabs");return h(),o("div",null,[l[6]||(l[6]=i('<h1 id="_4-1-理解tcp-和-udp" tabindex="-1"><a class="header-anchor" href="#_4-1-理解tcp-和-udp"><span>4.1 理解TCP 和 UDP</span></a></h1><h2 id="协议" tabindex="-1"><a class="header-anchor" href="#协议"><span>协议</span></a></h2><p>协议的组成要素：<br> 语法：数据与控制信息的结构或格式。如何解析<br> 语义：需要发出何种控制信息，完成何种动作以及做出何种响应。如何操控。<br> 同步：事件实现的顺序。操作流程，保证双方状态一致。</p><h2 id="层次划分" tabindex="-1"><a class="header-anchor" href="#层次划分"><span>层次划分</span></a></h2><p>划分层次后网络传输文件的过程：<br><img src="'+m+'" alt="" loading="lazy"></p><p>本来想用mermaid 的flowchart 画的，但是不知道怎么分列，改用whiteboard 绘制<br> 发送方：文件传输模块将文件或命令给到通信服务模块，通信服务模块再通过接入模块发送。<br> 接收方：接入模块收到数据后向上递交给通信服务模块，通信服务模块保证数据有效（顺序、内容正确），然后再递交给文件传送模块。最后由文件模块解析数据或响应命令。</p><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>文件传输模块</td><td>获取指定文件、发送文件、删除文件。。。</td></tr><tr><td>通信服务模块</td><td>建立通讯、断开通讯、通信数据有效。。。</td></tr><tr><td>网络接入模块</td><td>建立物理连接通道，收发数据</td></tr></tbody></table><p>分层后相同层级之间的模块是对等的，进行处理时好像它们之间是在直接通话，而不是经过了底层模块的传递。<br> 各层的功能、目的明确。文件模块只处理文件相关的内容，至于文件数据的传输则由通信模块处理。</p><h3 id="标准体系结构" tabindex="-1"><a class="header-anchor" href="#标准体系结构"><span>标准体系结构</span></a></h3>',9)),s(r,{data:[{id:"OSI"},{id:"TCP/IP 四层协议"},{id:"五层协议"}]},{title0:n(({value:e,isActive:d})=>[...l[0]||(l[0]=[u("OSI",-1)])]),title1:n(({value:e,isActive:d})=>[...l[1]||(l[1]=[u("TCP/IP 四层协议",-1)])]),title2:n(({value:e,isActive:d})=>[...l[2]||(l[2]=[u("五层协议",-1)])]),tab0:n(({value:e,isActive:d})=>[...l[3]||(l[3]=[t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"层级"),t("th",null,"名称"),t("th",null,"功能"),t("th",null,"信息分组名称"),t("th",null,"协议/服务"),t("th",null,"说明")])]),t("tbody",null,[t("tr",null,[t("td",null,"7"),t("td",null,"应用层"),t("td",null,"网络应用程序及它们的协议存留的地方"),t("td",null,"报文"),t("td",null,"HTTP, SMTP, FTP, DNS"),t("td")]),t("tr",null,[t("td",null,"6"),t("td",null,"表示层"),t("td",null,"使通信的应用程序能够解释交换数据的含义"),t("td"),t("td"),t("td")]),t("tr",null,[t("td",null,"5"),t("td",null,"会话层"),t("td",null,"提供数据交换的定界和同步功能"),t("td"),t("td"),t("td")]),t("tr",null,[t("td",null,"4"),t("td",null,"运输层"),t("td",null,"传输应用层报文"),t("td",null,"报文段"),t("td",null,"TCP，UDP"),t("td")]),t("tr",null,[t("td",null,"3"),t("td",null,"网络层"),t("td",null,"在主机之间传递数据。路由选择"),t("td",null,"数据包（报）"),t("td",null,"IP"),t("td",null,"面向消息，不可靠；")]),t("tr",null,[t("td",null,"2"),t("td",null,"数据链路层"),t("td",null,"在相邻网络元素（节点）间移动帧"),t("td",null,"帧（frame）"),t("td",null,"以太网、WiFi、ARP"),t("td",null,"一个数据报可能被沿途不同链路上的不同链路层协议处理。WiFi-》以太网-》other。 或者主机包含多种链路，网络层需要处理不同链路过来的数据报")]),t("tr",null,[t("td",null,"1"),t("td",null,"物理层"),t("td",null,"在相邻节点间移动bit"),t("td",null,"比特流（bit-flow）"),t("td",null,"以太网：双绞铜线、同轴电缆、光纤"),t("td")])])],-1)])]),tab1:n(({value:e,isActive:d})=>[...l[4]||(l[4]=[t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"层级"),t("th",null,"名称")])]),t("tbody",null,[t("tr",null,[t("td",null,"4"),t("td",null,"应用层")]),t("tr",null,[t("td",null,"3"),t("td",null,"运输层")]),t("tr",null,[t("td",null,"2"),t("td",null,"网际（络）层 （IP层）")]),t("tr",null,[t("td",null,"1"),t("td",null,"网络接口层")])])],-1)])]),tab2:n(({value:e,isActive:d})=>[...l[5]||(l[5]=[t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"层级"),t("th",null,"名称")])]),t("tbody",null,[t("tr",null,[t("td",null,"5"),t("td",null,"应用层")]),t("tr",null,[t("td",null,"4"),t("td",null,"运输层")]),t("tr",null,[t("td",null,"3"),t("td",null,"网络层")]),t("tr",null,[t("td",null,"2"),t("td",null,"数据链路层")]),t("tr",null,[t("td",null,"1"),t("td",null,"物理层")])])],-1)])]),_:1})])}const g=a(c,[["render",P]]),f=JSON.parse('{"path":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/4.1%20%E7%90%86%E8%A7%A3TCP%20%E5%92%8C%20UDP.html","title":"4.1 理解TCP 和 UDP","lang":"zh-CN","frontmatter":{"category":"网络编程","description":"4.1 理解TCP 和 UDP 协议 协议的组成要素： 语法：数据与控制信息的结构或格式。如何解析 语义：需要发出何种控制信息，完成何种动作以及做出何种响应。如何操控。 同步：事件实现的顺序。操作流程，保证双方状态一致。 层次划分 划分层次后网络传输文件的过程： 本来想用mermaid 的flowchart 画的，但是不知道怎么分列，改用whitebo...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"4.1 理解TCP 和 UDP\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-08T13:33:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"mingStudent\\"}]}"],["meta",{"property":"og:url","content":"https://guzhoutingxue.github.io/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/4.1%20%E7%90%86%E8%A7%A3TCP%20%E5%92%8C%20UDP.html"}],["meta",{"property":"og:title","content":"4.1 理解TCP 和 UDP"}],["meta",{"property":"og:description","content":"4.1 理解TCP 和 UDP 协议 协议的组成要素： 语法：数据与控制信息的结构或格式。如何解析 语义：需要发出何种控制信息，完成何种动作以及做出何种响应。如何操控。 同步：事件实现的顺序。操作流程，保证双方状态一致。 层次划分 划分层次后网络传输文件的过程： 本来想用mermaid 的flowchart 画的，但是不知道怎么分列，改用whitebo..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-08T13:33:52.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-08T13:33:52.000Z"}]]},"git":{"createdTime":1759676228000,"updatedTime":1759930432000,"contributors":[{"name":"guZhouTingXue","username":"guZhouTingXue","email":"2422173022@qq.com","commits":2,"url":"https://github.com/guZhouTingXue"}]},"readingTime":{"minutes":2.37,"words":711},"filePathRelative":"网络编程/4.1 理解TCP 和 UDP.md","excerpt":"","autoDesc":true}');export{g as comp,f as data};
