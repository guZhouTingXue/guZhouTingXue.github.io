import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,d as n,f as t,a as i,e as a,r as p,o as h}from"./app-BfwbC3B8.js";const k={};function d(o,s){const e=p("Mermaid");return h(),r("div",null,[s[0]||(s[0]=n('<h1 id="strategy" tabindex="-1"><a class="header-anchor" href="#strategy"><span>Strategy</span></a></h1><h2 id="简单的模拟鸭子应用" tabindex="-1"><a class="header-anchor" href="#简单的模拟鸭子应用"><span>简单的模拟鸭子应用</span></a></h2><h3 id="鸭子类" tabindex="-1"><a class="header-anchor" href="#鸭子类"><span>鸭子类</span></a></h3>',3)),t(e,{code:"eJxLzkksLnbJTEwvSsxV4OIEcxVcSpOzFaq5ODkLSxOTszU0gazi8sxcMCMls7ggJ7ESxK7lAgBm1RID"}),s[1]||(s[1]=i("p",null,"基类：所有的鸭子都会叫、游泳",-1)),t(e,{code:"eJxLzkksLnbJTEwvSszl4gTzFFxKk7O5OH0Tc3ISi0BsBV3dGjuoaFBqYkoGEKOLI6m2UkjJLC7ISazU0FTQ13+6ZNqL5U3PZqx/vnv/0yVb0EzApXbXIpBaACvTPeg="}),s[2]||(s[2]=i("p",null,[a("让鸭子飞起来"),i("br"),a(" 在Duck中添加方法：所有的鸭子都会飞了")],-1)),s[3]||(s[3]=i("p",null,[a("可怕的问题"),i("br"),a(" 橡皮鸭现在也会飞")],-1)),s[4]||(s[4]=i("p",null,"继承？",-1)),t(e,{code:"eJxLzkksLnbJTEwvSszl4gTzFFxKk7O5OH0Tc3ISi0BsBV3dGjuoaFBqYkoGEKOLI6m2UkjJLC7ISazU0FTQ13+6ZNqL5U3PZqx/vnv/0yVb0EzApXbXIoja0qSkVEw3IEStFApLE5OzIbonbASh/tVoKpBteLZy4fNZ617uWMsFAE2KYWw="}),s[5]||(s[5]=i("pre",null,[i("code",null,`子类覆盖基类定义的方法
`)],-1)),s[6]||(s[6]=i("p",null,"缺点：所有的子类都需要判断是否需要覆盖基类的方法。基类的方法改变，子类也要跟着修改。",-1)),s[7]||(s[7]=i("p",null,[a("接口？"),i("br"),a(" 将方法作为接口使用")],-1)),t(e,{code:"eJxLzkksLnbJTEwvSszl4lQAcxXccioTk3JSFaoVbGw880pSi9ISk1Pt7BSACtJyKjU0FWrhSgNLE5OzcSkuBElClENUu5QmZytUc3FyFpdn5mpoAhkpmcUFOYlAM7k4a7m4OGE22+jpKfgm5uQkFoG0cHEirEGXARtpU6OriyKKriMoNTElA4jR9aCIAwB5F1Iu"}),s[8]||(s[8]=n('<p>缺点：代码无法复用，每种鸭子类都要实现接口。</p><h2 id="设计原则" tabindex="-1"><a class="header-anchor" href="#设计原则"><span>设计原则</span></a></h2><p>继承不适用于解决经常变化的问题。<br> JAVA中接口不能继承，C++中接口（抽象类）可以继承。在JAVA中同样不能使用接口解决经常变化的问题。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>找出应用中可能需要变换之处，把它们独立出来，不要和哪些不需要变换的代码混在一起。</p></div><h2 id="重新设计鸭子" tabindex="-1"><a class="header-anchor" href="#重新设计鸭子"><span>重新设计鸭子</span></a></h2><p>实现的鸭子是笼统的鸭子，只有具有鸭子的外观，其余部分没有要求。<br> 分离变化的部分：将fly 和 quack 放到单独的类中，通过它们提供的接口实行具体的行为。<br> 接口是不变的，但是具体的实现是可变的。</p>',6)),t(e,{code:"eJxLzkksLnbJTEwvSszl4gTzFNxyKp1SMxLLMvOLFKoVbGw880pSi9ISk1Pt7Lg4a7k4keVtavT0QBrCM0sywjPz0ouxS/vlhydWcgEABkcktg=="}),s[9]||(s[9]=i("h3",{id:"针对接口-而不是具体实现编程",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#针对接口-而不是具体实现编程"},[i("span",null,"针对接口，而不是具体实现编程")])],-1)),s[10]||(s[10]=i("blockquote",null,[i("p",null,"针对接口的真正意思是针对超类型编程")],-1)),s[11]||(s[11]=i("p",null,[a("超类型-抽象类。利用多态，所有基类指针/引用都可以用子类指针/引用 替换。"),i("br"),a(" 具体实现：子类"),i("br"),a(" 举例：")],-1)),t(e,{code:"eJxLzkksLnbJTEwvSszl4gTzFBzzMnMTcxSquTg5tRVyE7NTg/NL81I0NBW4OGthalzy0zEVgPlJicnZICZQKUiRrm6NHdRELk6YbufEEqzGgwRS88uh2kGqkLUDAMg1L4M="}),s[12]||(s[12]=n(`<p>针对实现：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Dog </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">d </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Dog</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">d</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">back</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>调用的方法和实现绑定，如果更换为其他动物必须修改代码。<br> 更换为cat后</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Cat </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">c </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Cat</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">c</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">meow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>针对接口：<br> 在抽象类中定义接口，通过调用接口处理逻辑</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Animal </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">animal </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Dog</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">animal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">makeSound</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="整合" tabindex="-1"><a class="header-anchor" href="#整合"><span>整合</span></a></h3>`,7)),t(e,{code:"eJxtjrEOgjAYhOfyFB11gCdoGAwxcdBEF+bfttCGQrEFkwZ8d9tGTWPY/rsv/91RBdZWEloDfYaiwtVMO7xkCB2VO3ABT6kNbpS7f25PrjPQ7sceqfKUSTsqcLu9v0duGm16HxXkK0Mxnax5js+gFJigU/fGmeDAov1dlA5ZMCGnYfKxQHlZxsyUk7UowkMtJ1HLobXb+KJrcH/It8faN5mgWkA="}),s[13]||(s[13]=i("h3",{id:"策略模式的定义",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#策略模式的定义"},[i("span",null,"策略模式的定义")])],-1)),s[14]||(s[14]=i("blockquote",null,[i("p",null,[a("[!quote]"),i("br"),a(" 定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。")])],-1))])}const c=l(k,[["render",d]]),u=JSON.parse('{"path":"/Design%20Patterns/Strategy%20-%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8.html","title":"Strategy","lang":"zh-CN","frontmatter":{"category":"DesignPatterns","description":"Strategy 简单的模拟鸭子应用 鸭子类 基类：所有的鸭子都会叫、游泳 让鸭子飞起来 在Duck中添加方法：所有的鸭子都会飞了 可怕的问题 橡皮鸭现在也会飞 继承？ 缺点：所有的子类都需要判断是否需要覆盖基类的方法。基类的方法改变，子类也要跟着修改。 接口？ 将方法作为接口使用 缺点：代码无法复用，每种鸭子类都要实现接口。 设计原则 继承不适用于解...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Strategy\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-24T15:40:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"mingStudent\\"}]}"],["meta",{"property":"og:url","content":"https://guzhoutingxue.github.io/Design%20Patterns/Strategy%20-%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8.html"}],["meta",{"property":"og:title","content":"Strategy"}],["meta",{"property":"og:description","content":"Strategy 简单的模拟鸭子应用 鸭子类 基类：所有的鸭子都会叫、游泳 让鸭子飞起来 在Duck中添加方法：所有的鸭子都会飞了 可怕的问题 橡皮鸭现在也会飞 继承？ 缺点：所有的子类都需要判断是否需要覆盖基类的方法。基类的方法改变，子类也要跟着修改。 接口？ 将方法作为接口使用 缺点：代码无法复用，每种鸭子类都要实现接口。 设计原则 继承不适用于解..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-24T15:40:41.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-24T15:40:41.000Z"}]]},"git":{"createdTime":1756050041000,"updatedTime":1756050041000,"contributors":[{"name":"guZhouTingXue","username":"guZhouTingXue","email":"2422173022@qq.com","commits":1,"url":"https://github.com/guZhouTingXue"}]},"readingTime":{"minutes":2.24,"words":673},"filePathRelative":"Design Patterns/Strategy - 设计模式入门.md","excerpt":"","autoDesc":true}');export{c as comp,u as data};
