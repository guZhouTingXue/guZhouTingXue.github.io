import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,a as s,f as a,d as l,e as t,w as p,r as h,o}from"./app-BKU-FXl8.js";const k={},g={style:{background:"#fff88f"}};function A(c,i){const e=h("Mermaid"),n=h("font");return o(),d("div",null,[i[1]||(i[1]=s("h1",{id:"_9-3-tcp-nodelay",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_9-3-tcp-nodelay"},[s("span",null,"9.3 TCP_NODELAY")])],-1)),i[2]||(i[2]=s("p",null,"用来控制是否开启 Nagle 算法",-1)),i[3]||(i[3]=s("h2",{id:"nagle-算法",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#nagle-算法"},[s("span",null,"Nagle 算法")])],-1)),i[4]||(i[4]=s("blockquote",null,[s("p",null,[t("info"),s("br"),t(" 只有收到前一数据的ACK消息时，Nagle 算法才发送下一数据")])],-1)),i[5]||(i[5]=s("p",null,"书中的示例：",-1)),a(e,{code:"eJwrTi0sTc1LTnXJTEwvSszl4kzKr1DwS0zPSX2+bvqzzVP9/bg4CxKLSjKTMwsS80oUkkrT0gwUEosVnuzY/WzOLkeF53smP23b9LRnF6o6RxQ1eyc+3z3nWd/Sp/2LUZU5IZQ5KXBxpualcCkAAcQWXTs7BUcrBXU/dS5ORzDPyUohJbEkESyEqS4Rm2A6NsEcbIKpQGucYDxHZ2+QLUA3odkMChoMhWBBkIkKQA1cAGnha0Q="}),a(e,{code:"eJwrTi0sTc1LTnXJTEwvSszl4kzKr1DwS0zPSX2+bvqzzVP93dy4OAsSi0oykzMLEvNKFJJK09IMFRKLFZ7s2P1szi5Hhed7Jj9t2/S0ZxeqOmcUNXsnPt8951nf0qf9i1GVuSCUOSlwcabmpXApAAHEFl07OwVnKwV1P3UuTmcwz8VKISWxJBEshKkuEVMdUAhTXTqmOpCQC0yBo7M3Dhty1IGORNOag6EVq6Wp6kAhDM2pQM3o2tNBKoFKUUWBVmMRBZnKBQD2fIGD"}),i[6]||(i[6]=l('<p>经由tcp发送的数据首先到达TCP socket 的发送缓冲区。</p><ol><li>假设发送字符串 &#39;Nagle&#39;，每个字符间隔一段时间依次达到发送缓冲区。</li><li>’N‘前面没有其他数据（&#39;N’是第一包用户数据）</li><li>使用Nagle时，在收到 ‘N’ 的ACK前，‘a’、‘g’，‘l&#39;，’e&#39; 都已经达到缓冲区</li><li>不使用Nagle时，只要缓冲区接收到数据就立即发送，不等待ACK</li></ol><p><span style="background:#fff88f;">问题：</span>为什么sequenceDiagram 中 第二个group box的第一条消息显示在了前一个box的最后一条消息的下面？在sequenceDiagram 中后出现的就要显示在下面？不能并排？主要是这两个box之间没有关联，相互独立。如果有消息传递那后出现的在下面算是合理。暂时换一种方式，分为两个代码块，避免显示补全导致的拖动。</p><p><span style="background:#fff88f;">问：</span></p><ol><li>采用Nagle时，如果一直没有收到前面数据的ACK 会怎么样？重新发送前面的数据？判定为连接断开？</li><li>采用Nagle时，如果缓冲区满了怎么办？</li><li>采用Nagle 和 不采用Nagle时，发送数据的条件分别是什么？接受前面数据ACK 是否是唯一的条件？</li></ol><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>TCP套接字默认使用Nagle算法交换数据，因此最大限度地进行缓冲，直到收到ACK。</p></div><p>对上面这段话，我的理解：<br> 使用Nagle时，发送数据有两种情况，1. 收到ACK；2. 缓冲区满。</p><p>完成字符串所需的数据包</p><table><thead><tr><th>是否启用Nagle</th><th>数据包数量</th></tr></thead><tbody><tr><td>启用</td><td>4</td></tr><tr><td>不启用</td><td>10</td></tr></tbody></table><p>对比启用 和 关闭 Nagle 算法，Nagle 能够减少数据包（不必要的流量-头信息）。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>网络流量未受太大影响时，不使用Nagle算法要比使用它时传输速度快。</p></div><p>在传输大文件数据时：</p><ol><li>传输的数据比较多，数据包数量多。</li><li>填充缓冲区的速度比较快<br> 如果使用Nagle，假设从上一包数据发送到接收到ACK 平均耗时1s，1000包数据就多等待1000s。写入缓冲比较快，相当于流水线前道工序做的快，后面的工序慢 就浪费了前面的工作效率。<br> 关闭Nagle可以快速的把数据发送出去，不用经过了漫长的等待时间。</li></ol><p>等待ACK既有优点，也有缺点。不同的情况下权衡利弊，做出合理的选择。</p>',14)),a(n,{color:"#ffff00"},{default:p(()=>[s("span",g,[a(n,{color:"#ffff00"},{default:p(()=>[...i[0]||(i[0]=[t("问：",-1)])]),_:1})])]),_:1}),i[7]||(i[7]=l(`关闭Nagle，缓冲区满了就会发送数据。假设发送了1000包，TCP缓冲容量10包，TCP是怎么保证可靠传输的？是即使关闭了Nagle，也限制了在 TCP缓冲容量范围内的包确认后才可以继续发送，还是有其他机制？<h2 id="设置" tabindex="-1"><a class="header-anchor" href="#设置"><span>设置</span></a></h2><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;netinet/tcp.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> opt_val;</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">    socklen_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> optlen;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    optlen </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(opt_val);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    getsockopt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(sock, IPPROTO_TCP, TCP_NODELAY, (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">opt_val, </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">optlen);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;TCP_NODELAY:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, opt_val);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    opt_val </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    setsockopt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(sock, IPPROTO_TCP, TCP_NODELAY, (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">opt_val, optlen);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>行号</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>1-6</td><td>查看当前TCP_NODELAY的值</td><td>默认开启Nagle算法，TCP_NODELAY值为0</td></tr><tr><td>8-9</td><td>设置为NODELAY</td><td>关闭Nagle算法</td></tr></tbody></table><h2 id="测试" tabindex="-1"><a class="header-anchor" href="#测试"><span>测试</span></a></h2><p>暂时想到的两种方法：</p><ol><li>控制ACK的回复：可控制的ACK回复，或者 是模拟的网络阻塞、传输缓慢</li><li>控制写入缓冲区：这个要怎么搞？手写驱动？</li></ol>`,7))])}const u=r(k,[["render",A]]),C=JSON.parse(`{"path":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/9.3%20TCP_NODELAY.html","title":"9.3 TCP_NODELAY","lang":"zh-CN","frontmatter":{"category":"网络编程","description":"9.3 TCP_NODELAY 用来控制是否开启 Nagle 算法 Nagle 算法 info 只有收到前一数据的ACK消息时，Nagle 算法才发送下一数据 书中的示例： 经由tcp发送的数据首先到达TCP socket 的发送缓冲区。 假设发送字符串 'Nagle'，每个字符间隔一段时间依次达到发送缓冲区。 ’N‘前面没有其他数据（'N’是第一包用...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"9.3 TCP_NODELAY\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-11T17:56:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"mingStudent\\"}]}"],["meta",{"property":"og:url","content":"https://guzhoutingxue.github.io/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/9.3%20TCP_NODELAY.html"}],["meta",{"property":"og:title","content":"9.3 TCP_NODELAY"}],["meta",{"property":"og:description","content":"9.3 TCP_NODELAY 用来控制是否开启 Nagle 算法 Nagle 算法 info 只有收到前一数据的ACK消息时，Nagle 算法才发送下一数据 书中的示例： 经由tcp发送的数据首先到达TCP socket 的发送缓冲区。 假设发送字符串 'Nagle'，每个字符间隔一段时间依次达到发送缓冲区。 ’N‘前面没有其他数据（'N’是第一包用..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-11T17:56:24.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-11T17:56:24.000Z"}]]},"git":{"createdTime":1765475784000,"updatedTime":1765475784000,"contributors":[{"name":"guZhouTingXue","username":"guZhouTingXue","email":"2422173022@qq.com","commits":1,"url":"https://github.com/guZhouTingXue"}]},"readingTime":{"minutes":3.55,"words":1064},"filePathRelative":"网络编程/9.3 TCP_NODELAY.md","excerpt":"","autoDesc":true}`);export{u as comp,C as data};
