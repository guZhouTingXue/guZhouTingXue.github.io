---
category: ç½‘ç»œç¼–ç¨‹
---
# 18.4 çº¿ç¨‹åŒæ­¥
>[!info]
>çº¿ç¨‹åŒæ­¥ç”¨äºè§£å†³çº¿ç¨‹è®¿é—®é¡ºåºå¼•å‘çš„é—®é¢˜ã€‚

## äº’æ–¥é‡ Mutual Exclusion
ç›¸äº’æ’æ–¥
ä¹Ÿå«åšäº’æ–¥é”
äº’æ–¥é”çš„ä½œç”¨ï¼šä¿è¯åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½å¤Ÿè®¿é—®åŒä¸€å—ä¸´ç•ŒåŒºï¼ˆé€ æˆå¼‚å¸¸çš„ä»£ç ï¼‰

``` mermaid
classDiagram
    class mutex{
        pthread_mutex_init(mutex, attr) int
        pthread_mutex_destroy(mutex) int
        pthread_mutex_lock(mutex) int
        pthread_mutex_unlock(mutex) int
    }
```

ä½¿ç”¨mutexçš„é€»è¾‘ï¼š
``` mermaid
graph TD
    mutex@{shape:text, label:"pthread_mutex_init
    åˆ›å»ºå¹¶åˆå§‹åŒ–"}
    subgraph t0["çº¿ç¨‹0"]
        lock0["pthread_mutex_lock(&mutex) åŠ é”"]
        J0@{ shape: diamond, label: "æ˜¯å¦æœ‰çº¿ç¨‹åœ¨è®¿é—®ä¸´ç•ŒåŒºï¼Ÿ
        <=> æ˜¯å¦å·²ä¸Šé”" }
        a["è®¿é—®ä¸´ç•ŒåŒº"]
        unlock0["pthread_mutex_unlock(&mutex) è§£é”"]
        lock0 --> J0 --> |æ²¡æœ‰å…¶ä»–çº¿ç¨‹è®¿é—®ä¸´ç•ŒåŒº <br> æœªä¸Šé”| a --> unlock0
    end

    subgraph t1["çº¿ç¨‹1"]
        lock1["pthread_mutex_lock(&mutex) åŠ é”"]
        J1@{ shape: diamond, label: "æ˜¯å¦ä¸Šé”"}
        b["è®¿é—®ä¸´ç•ŒåŒº"]
        unlock1["pthread_mutex_unlock(&mutex) è§£é”"]
        w["ç­‰å¾…è§£é”"]
        lock1 --> J1 -->|å¦| b --> unlock1
        J1 -->|æ˜¯| w
        w --> b
    end
    mutex --> t0
    unlock0 --> w
```

- åœ¨è®¿é—®ä¸´ç•ŒåŒºå‰è¿›è¡Œlockï¼Œè®¿é—®ç»“æŸåè¿›è¡Œunlockã€‚
- å¦‚æœçº¿ç¨‹0è®¿é—®åæ²¡æœ‰unlockï¼Œé‚£ä¹ˆçº¿ç¨‹1ä¼šä¸€ç›´ç­‰å¾…è§£é”ï¼Œé€ æˆçº¿ç¨‹1æ— æ³•è®¿é—®ä¸´ç•ŒåŒº - æ­»é”ã€‚
- å¤šä¸ªçº¿ç¨‹ä½¿ç”¨çš„æ˜¯åŒä¸€ä¸ªmutexï¼Œé€šè¿‡è¯¥mutexçš„çŠ¶æ€åˆ¤æ–­ä¸´ç•ŒåŒºçš„è®¿é—®æƒ…å†µã€‚
## æŸ¥çœ‹mutexç›¸å…³å‡½æ•°å¸®åŠ©
1. æŸ¥è¯¢pthread_mutex_init çš„å¸®åŠ©ï¼Œæç¤ºmanual ä¸­æ²¡æœ‰å¯¹åº”entryçš„ä¿¡æ¯ã€‚
```
mingstudent@mingstudent:/mnt/c/Users/mingstudent/Desktop$ man pthread_mutex_init
No manual entry for pthread_mutex_init
```


2. ä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤å®‰è£…POSIX å¼€å‘æ‰‹å†Œ
``` cmd
sudo apt install manpages-posix-dev
```

3. å®‰è£…æˆåŠŸåå†æ¬¡æŸ¥è¯¢
``` cpp
PROLOG
       This  manual  page  is  part of the POSIX Programmer's Manual.  The Linux implementation of this interface may
       differ (consult the corresponding Linux manual page for details of Linux behavior), or the interface  may  not
       be implemented on Linux.

NAME
       pthread_mutex_init â€” destroy and initialize a mutex

SYNOPSIS
       #include <pthread.h>

       int pthread_mutex_init(pthread_mutex_t *restrict mutex,
           const pthread_mutexattr_t *restrict attr);
       pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
```

mutexçš„ç±»å‹ä¸ºï¼špthread_mutex_t
åˆ›å»ºä¸€ä¸ªmutexçš„æ–¹å¼æœ‰ä¸¤ç§ï¼š
``` cpp
	pthread_mutex_t mutex;
	pthread_mutex_init(&mutex);
	
	pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
```
- 1ã€2è¡Œï¼Œä½¿ç”¨å‡½æ•°è¿›è¡Œåˆå§‹åŒ–
- ä½¿ç”¨å®è¿”å›çš„æ— å±æ€§é…ç½®ï¼ˆattr = NULLï¼‰çš„mutex
<span style="background:#fff88f">é—®ï¼š</span>è¿™ä¸ªå®å…·ä½“æ˜¯ä¸€ä¸ªå‡½æ•°è¿˜æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„å€¼ï¼Ÿæ˜¯åœ¨ç¼–è¯‘æ—¶æœŸå®Œæˆ è¿˜æ˜¯ è¿è¡Œæ—¶å™¨ç”Ÿæˆï¼Ÿ

>æ¨èä½¿ç”¨pthread_mutex_init å‡½æ•°è¿›è¡Œåˆå§‹åŒ–

å› ä¸ºå¯ä»¥é€šè¿‡å‡½æ•°è¿”å›å€¼åˆ¤æ–­åˆå§‹åŒ–æ˜¯å¦æˆåŠŸ

## æµ‹è¯•
å®ç°ï¼š
``` cpp
pthread_mutex_t mutex;

void* thread_inc(void* arg)
{
	long i;
	pthread_mutex_lock(&mutex);
	for(i=0; i<5000000000; i++)
		num++;
	pthread_mutex_unlock(&mutex);
	return NULL;
}
int main(int argc, char* argv[])
{
	pthread_t tid0, tid1;
	pthread_mutex_init(&mutex, NULL);
	//ã€‚ã€‚ã€‚
}
```

| è¡Œå·  | åŠŸèƒ½               | è¯´æ˜         |
| --- | ---------------- | ---------- |
| 1   | å®šä¹‰ç”¨äºé”å®šä¸´ç•ŒåŒºçš„mutex  | å…¨å±€å˜é‡ï¼Œå¤šçº¿ç¨‹å…±äº« |
| 6ã€9 | ç»™ä¸´ç•ŒåŒºä¸Šé”ã€è§£é”        |            |
| 15  | ä½¿ç”¨mutexå‰åˆå§‹åŒ–mutex |            |

æ•ˆæœï¼š
```
ming@ubuntu:/media/sf_share/Network/build$ ./Network
num: 0
ming@ubuntu:/media/sf_share/Network/build$ ./Network
num: 0
```
åŠ äº†é”ä¹‹åå¤šçº¿ç¨‹ä¸ä¼šåŒæ—¶ä¿®æ”¹å…¨å±€å˜é‡numï¼Œå¤šæ¬¡è¿è¡Œç»“æœæ­£ç¡®ã€‚
### ä¸´ç•ŒåŒºçš„èŒƒå›´
1. åªè¦åŒ…å«äº†å¯èƒ½å¼•èµ·é—®é¢˜çš„ä»£ç çš„åŒºåŸŸå°±å¯ä»¥æ˜¯ä¸´ç•ŒåŒº
2. =ã€‹ä¸´ç•ŒåŒºçš„èŒƒå›´å¯å¤§å¯å°

``` cpp
	for(i=0; i<5000000000; i++)
		num++;
```
æ¯”å¦‚ä¸Šé¢çš„ä»£ç ä¸­ï¼Œä¸´ç•ŒåŒºå¯ä»¥æ˜¯1ã€2 ä¸¤æ¡è¯­å¥ï¼Œä¹Ÿå¯ä»¥æ˜¯ç¬¬2è¡Œ - å•æ¡è¯­å¥ã€‚
åŠ é”çš„æ“ä½œå¯ä»¥æ˜¯å¯¹ forå¾ªç¯ å’Œ numæ“ä½œ ä¸€èµ·åŠ é”ï¼Œä¹Ÿå¯ä»¥æ˜¯ä»…å¯¹numæ“ä½œåŠ é”
``` cpp
	for(i=0; i<5000000000; i++)
	{
		pthread_mutex_lock(&mutex);
		num++;
		pthread_mutex_unlock(&mutex);
	}
```

ä¸¤è€…çš„åŒºåˆ«ï¼š

| æ–¹å¼                   | lockã€unlockæ¬¡æ•° | ç‰¹ç‚¹                                                                                 | æ—¶é—´                                                                                        |
| -------------------- | ------------- | ---------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| for + num ï¼šå¾ªç¯å‰ååŠ é”ã€è§£é” | 1             | ç›¸å½“äºå…¶ä¸­ä¸€ä¸ªçº¿ç¨‹è¦å®Œå…¨ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œå®Œå¯¹numçš„æ“ä½œç„¶åæ‰å¯ä»¥è®¿é—®<br>â€æœ€å¤§é™åº¦å‡å°‘äº’æ–¥é‡lockã€unlockå‡½æ•°è°ƒç”¨çš„æ¬¡æ•°â€œï¼Œå¯¹äº’æ–¥é”çš„æ“ä½œä¹Ÿéœ€è¦è¿ç®— | beginï¼š1769273439 - 2026-01-25 00:50:39<br>end: 1769273462 - 2026-01-25 00:51:02<br>å…±ï¼š23s  |
| numï¼šå¾ªç¯å†…              | å¾ªç¯æ¬¡æ•°          | ä¸¤ä¸ªçº¿ç¨‹äº¤æ›¿å¯¹numè¿›è¡Œæ“ä½œ                                                                     | beginï¼š1769273575 - 2026-01-25 00:52:55<br>end: 1769273730 - 2026-01-25 00:55:30<br>å…±ï¼š155s |

ä¸¤ç§æ–¹å¼è¿è¡Œæ—¶é—´ç›¸å·®132sï¼Œå¯ä»¥çœ‹åˆ°å¦‚æœå¾ªç¯æ¬¡æ•°è¿‡å¤šï¼Œé¢‘ç¹lockã€unlock ä¸¥é‡å½±å“æ€§èƒ½ã€‚

å¢åŠ æ—¶é—´æˆ³æ‰“å°ï¼š
``` cpp
#include<time.h>
int main()
{
	time_t now = time(NULL); 
    printf("begin time: %ld\n", (long)now);
}
```

| è¡Œå·  | åŠŸèƒ½                                                                                                 | è¯´æ˜               |
| --- | -------------------------------------------------------------------------------------------------- | ---------------- |
| 4   | time() returns the time as the number of seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC). | timeè¿”å›è·ç¦»Epochçš„ç§’æ•° |

ç”¨åœ¨çº¿å·¥å…·è½¬æ¢æˆæ—¶åˆ†ç§’æ ¼å¼


## ä¿¡å·é‡ semaphore
``` mermaid
classDiagram
    class semaphore{
        sem_init(sem, pshared, value) int
        sem_destroy(sem) int
        sem_post(sem) int
        sem_wait(sem) int
    }
```

### sem_init
``` cpp
NAME
       sem_init - initialize an unnamed semaphore

SYNOPSIS
       #include <semaphore.h>

       int sem_init(sem_t *sem, int pshared, unsigned int value);
```

| å‚æ•°      | å€¼          | ç”¨é€”                                                                                                                                                                                                                                                                                                               | è¯´æ˜                            |
| ------- | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------- |
| sem     |            | sem_init()  initializes  the  unnamed semaphore at the address pointed to by sem.                                                                                                                                                                                                                                | ä¿å­˜ä¿¡å·é‡çš„å˜é‡åœ°å€                    |
| pshared | 0; nonzero | The pshared argument indicates whether this semaphore is to  be  shared  between  the  threads  of  a process, or between processes.<br> If pshared has the value 0, then the semaphore is shared between the threads of a process, and should be located at some address that is visible to all threads <br>... | ä¿¡å·é‡æ˜¯åœ¨ä¸€ä¸ªè¿›ç¨‹å†…çš„çº¿ç¨‹ä¹‹é—´å…±äº«ï¼Œè¿˜æ˜¯åœ¨å¤šä¸ªè¿›ç¨‹ä¹‹é—´å…±äº« |
| value   |            | The value argument specifies the initial value for the semaphore.                                                                                                                                                                                                                                                | ä¿¡å·é‡çš„åˆå§‹å€¼                       |
| RETURN  | 0; -1      | returns 0 on success; on error, -1 is returned, and errno is set to indicate the error.                                                                                                                                                                                                                          |                               |
### sem_post
``` cpp
NAME
       sem_post - unlock a semaphore

SYNOPSIS
       #include <semaphore.h>

       int sem_post(sem_t *sem);

       Link with -pthread.

DESCRIPTION
       sem_post()  increments  (unlocks)  the  semaphore pointed to by sem.  If the semaphore's value consequently becomes greater than zero, then another process or thread blocked in a sem_wait(3) call  will be woken up and proceed to lock the semaphore.
```

- ä¿¡å·é‡æœ‰ä¸€ä¸ªåˆå§‹å€¼ï¼Œç±»å‹ä¸ºunsigned int ï¼ˆ >= 0 ï¼‰
- post å°† semaphore åŠ 1ï¼Œ wait å°† semaphore å‡1
- ä¿¡å·é‡çš„å€¼ä¸èƒ½å°äº0
- å¦‚æœå½“å‰sempahoreçš„å€¼æ˜¯0ï¼Œä½¿ç”¨poståï¼Œé˜»å¡åœ¨sem_waitï¼ˆï¼‰çš„çº¿ç¨‹ä¼šè¢«å”¤é†’ - æ‰§è¡Œï¼ŒåŒæ—¶semaphore è¢«lock 
### sem_wait
``` cpp
NAME
       sem_wait, sem_timedwait, sem_trywait - lock a semaphore

SYNOPSIS
       #include <semaphore.h>

       int sem_wait(sem_t *sem);

       int sem_trywait(sem_t *sem);

       int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);

       Link with -pthread.
       DESCRIPTION
       sem_wait()  decrements  (locks) the semaphore pointed to by sem.  If the semaphore's value is greater than zero, then the decrement proceeds, and the function returns, immediately.  If the semaphore currently has the value zero, then the  call blocks  until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal handler interrupts the call.
       sem_trywait() is the same as sem_wait(), except that if the decrement cannot be immediately performed, then call  returns an error (errno set to EAGAIN) instead of blocking.
```
åˆ¤æ–­semaphoreçš„å€¼ æ˜¯å¦ ä¸ºæ­£ã€‚ å¦‚æœ ä¸ºæ­£ï¼ˆ>0ï¼‰ï¼Œå°†semaphoreå‡1 å¹¶ ç«‹å³è¿”å›ï¼Œå¤„ç†ä¸´ç•ŒåŒºã€‚å¦‚æœ == 0 é˜»å¡ç­‰å¾…ç›´åˆ° semaphoreçš„å€¼ä¸º0
### ä½¿ç”¨semaphoreçš„è¿‡ç¨‹

``` mermaid
graph TD
    init@{shape: circ, label: "sem_init(, , value)"}
    p@{ shape: rect, label: "ä¸´ç•ŒåŒº"}
subgraph wait["wait"]
    d@{ shape: diam, label: "semçš„å€¼æ˜¯å¦ä¸ºæ­£ï¼Ÿ"}
    des@{ shape: rect, label: "sem - 1"}
    d --> |sem > 0|des 
    d --> |sem == 0| d
end
subgraph post["post"]
    inc@{ shape: rect, label: "sem + 1"}
end
    init --> |ç­‰å¾…æœ‰å¯ç”¨èµ„æº|wait -->|ä½¿ç”¨èµ„æº| p -->|é‡Šæ”¾èµ„æº| post
```

åœ¨ä¸´ç•ŒåŒºå‰è°ƒç”¨waitç­‰å¾…semaphoreçš„å€¼ >0ï¼Œä½¿ç”¨å®Œä¸´ç•ŒåŒºåè°ƒç”¨postå¢åŠ semaphoreçš„å€¼

### å¯¹ä¿¡å·é‡çš„ç†è§£
ä¿¡å·é‡çš„åˆå§‹å€¼å¯ä»¥çœ‹ä½œæ˜¯å¯ç”¨èµ„æºçš„æ•°é‡ã€‚

| æƒ…æ™¯  | mutex            | semaphore              |
| --- | ---------------- | ---------------------- |
| å•æ‰€  | å®¶é‡Œçš„å•æ‰€ï¼Œä¸€ä¸ªäººä½¿ç”¨å…¶ä½™äººç­‰å¾… | å…¬å…±å•æ‰€ï¼Œå¯ç”¨æœ‰å¤šä¸ªå°çš„éš”é—´ æˆ–è€… å‘ä½ğŸ˜ |

å°†ä¸´ç•ŒåŒºçœ‹ä½œèµ„æºï¼Œæ¯æ¬¡ä½¿ç”¨å‰éƒ½éœ€è¦ç¡®è®¤æœ‰èµ„æºå¯ç”¨ã€‚
å½“semaphoreçš„æœ€å¤§å€¼ä¸º1æ—¶å’Œmutex æ˜¯ä¸€ä¸ªæ•ˆæœã€‚

### æµ‹è¯•
å®ç°ï¼š
``` cpp
sem_t sem;
void* thread_inc(void* arg)
{
	long i;
	sem_wait(&sem);
	for(i=0; i<5000000000; i++)
		num++;
	sem_post(&sem);
	return NULL;
}

int main(int argc, char* argv[])
{
	sem_init(&sem, 0, 1);
	//ã€‚ã€‚ã€‚
}
```

æ•ˆæœï¼š
è€—æ—¶
beginï¼š1769345034 2026-01-25 20:43:54
endï¼š 1769345056 2026-01-25 20:44:16
å…±22s å’Œ ä½¿ç”¨mutexçš„æ•ˆç‡åŸºæœ¬ä¸€è‡´

### æŒ‡å®šè®¿é—®åŒä¸€å†…å­˜ç©ºé—´çš„çº¿ç¨‹æ‰§è¡Œé¡ºåº
mutex å’Œ semaphore é™¤äº†å¯ä»¥é¿å…å¤šçº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€å†…å­˜ç©ºé—´ï¼Œè¿˜å¯ä»¥æŒ‡å®šå¤šçº¿ç¨‹è®¿é—®çš„é¡ºåºã€‚
ä¹¦ä¸­çš„ç¤ºä¾‹ï¼š
>çº¿ç¨‹Aä»ç”¨æˆ·è¾“å…¥å¾—åˆ°å€¼åå­˜å…¥å…¨å±€å˜é‡numï¼Œæ­¤æ—¶çº¿ç¨‹Bå°†å–èµ°è¯¥å€¼å¹¶ç´¯åŠ ã€‚è¯¥è¿‡ç¨‹å…±è¿›è¡Œ5æ¬¡ï¼Œå®Œæˆåè¾“å‡ºæ€»å’Œå¹¶é€€å‡ºç¨‹åºã€‚

çº¿ç¨‹Aã€Bçš„æ‰§è¡Œæœ‰å…ˆåé¡ºåºã€‚
``` mermaid
graph TD
    sem_read@{ shape: cyl, label: "sem_t å¯ä»¥è¾“å…¥ init(, , 1)"}
    sem_cal@{ shape: cyl, label: "sem_t å¯ä»¥è®¡ç®— init(, , 0)"}

subgraph t0["çº¿ç¨‹A <br> è·å–è¾“å…¥"]
    wait0@{ shape: rect, label: "ç­‰å¾…è®¡ç®—çº¿ç¨‹è®¡ç®—å®Œæ¯•
    sem_wait0(&sem_read) <br> æ¶ˆè€—äº†è¾“å…¥çš„æœºä¼š"}
    input@{ shape: in-out, label: "ç”¨æˆ·è¾“å…¥"}
    post0@{ label: "sem_post(&sem_cal) <br> å¢åŠ å¯ä»¥è®¡ç®—çš„num"}
    j0@{ shape: diam, label: "æ˜¯å¦è¾“å…¥äº†5ä¸ªæ•°ï¼Ÿ"}
    r0["è¿”å›"]
    wait0 --> input --> post0 --> j0 --> |å°‘äº5ä¸ª|wait0 
    j0 -->|è¾¾åˆ°5ä¸ª| r0
end

subgraph t1["çº¿ç¨‹B <br> è®¡ç®—è¾“å…¥å’Œ"]
    wait1@{ label: "ç­‰å¾…è¾“å…¥ sem_wait(&sem_cal)"}
    cal@{ shape: rect, label: "è®¡ç®—è¾“å…¥å’Œ"}
    post1@{ label: "è®¡ç®—å®Œæ¯•ï¼Œå¯ä»¥ç»§ç»­è¾“å…¥ <br> sem_post(&sem_read)"}
    j1@{ shape: diam, label: "æ˜¯å¦è¾“å…¥äº†5ä¸ªæ•°ï¼Ÿ" }
    print[æ‰“å°æ€»å’Œ]
    r1[è¿”å›]
    
    wait1 -->cal --> post1 --> j1 --> |æ˜¯|print --> r1
    j1 -->|å¦| wait1
end

    post0 --> wait1
    post1 --> wait0
```
ä½¿ç”¨semaphore éœ€è¦æ˜ç¡®å®šä¹‰semaphore è¡¨ç¤ºçš„å«ä¹‰

>[!info]
>ä¸ºäº†å®Œæˆä¸Šè¿°è¦æ±‚æ„å»ºç¨‹åºï¼Œåº”æŒ‰ç…§çº¿ç¨‹Aã€çº¿ç¨‹Bçš„é¡ºåºè®¿é—®å˜é‡numï¼Œä¸”éœ€è¦çº¿ç¨‹åŒæ­¥


å®ç°ï¼š
``` cpp
sem_t sem_read;
sem_t sem_cal;
int num = 0;

void* read(void *)
{
	for(int i=0; i < 5; i++)
	{
		sem_wait(&sem_read); 
		printf("please input the number:");
		scanf("%d", &num);
		sem_post(&sem_cal);
	}
	return NULL;
}

void* cal(void *)
{
	int sum = 0;
	for(int i=0; i < 5; i++)
	{
		sem_wait(&sem_cal);
		sum += num;
		printf("current sum = %d\n", sum);
		sem_post(&sem_read);
	}
	printf("sum = %d\n", sum);
	return NULL;
}

int main(int argc, char* argv[])
{
	sem_init(&sem_read, 0, 1); 
	sem_init(&sem_cal, 0, 0);

	pthread_t tid1, tid2;
	pthread_create(&tid1, NULL, read, NULL);	
	pthread_create(&tid2, NULL, cal, NULL);	
	pthread_join(tid1, NULL);
	pthread_join(tid2, NULL);

	sem_destroy(&sem_read);
	sem_destroy(&sem_cal);

    return 0;
}
```

| è¡Œå·  | åŠŸèƒ½  | è¯´æ˜                      |
| --- | --- | ----------------------- |
| 33  |     | èµ„æºï¼šè·å–ç”¨æˆ·è¾“å…¥çš„æ¬¡æ•°ï¼›æ˜¯å¦å¯ä»¥è·å–ç”¨æˆ·è¾“å…¥ |
| 34  |     | èµ„æºï¼šæ˜¯å¦å¯ä»¥è¿›è¡Œè®¡ç®—ï¼›æ˜¯å¦å·²è·å–åˆ°ç”¨æˆ·è¾“å…¥  |

è®¡ç®—æ€»å’Œçš„çº¿ç¨‹ç›¸å½“äºæ¶ˆè´¹è€…ï¼Œè·å–ç”¨æˆ·è¾“å…¥çš„çº¿ç¨‹ç›¸å½“äºç”Ÿäº§è€…ã€‚åªæœ‰åœ¨ç”Ÿäº§è€…ç”Ÿäº§äº†èµ„æ–™ - è¿™é‡Œæ˜¯numï¼Œæ¶ˆè´¹è€…æ‰å¯ä»¥è¿›è¡Œæ¶ˆè´¹ã€‚è¿™æ ·å°±ç¡®å®šäº†çº¿ç¨‹å¯¹numçš„è®¿é—®é¡ºåºã€‚

æ•ˆæœï¼š
```
ming@ubuntu:/media/sf_share/Network/build$ ./Network
please input the number:4
current sum = 4
please input the number:8
current sum = 12
please input the number:-4
current sum = 8
please input the number:-2
current sum = 6
please input the number:5
current sum = 11
sum = 11
```



<span style="background:#fff88f">é—®ï¼š</span>ä¸ºä»€ä¹ˆè¦ç”¨ä¸¤ä¸ªsemaphoreæ¥è¿›è¡ŒåŒæ­¥ï¼Ÿä¸€ä¸ªè¡Œä¸è¡Œï¼Ÿ
1. semaphore åªåœ¨å€¼ä¸º0æ—¶å¯¹sem_waitï¼ˆï¼‰è¿›è¡Œé˜»å¡ - æ— æ³•è®¿é—®ä¸´ç•ŒåŒºï¼ˆä¿æŠ¤ä¸´ç•ŒåŒºï¼‰ï¼Œåœ¨å¤§äº0æ—¶ä¸ä¼šé˜»å¡ã€‚
å¦‚æœcal å’Œ read çº¿ç¨‹éƒ½æ˜¯wait -ã€‹è®¿é—® -ã€‹postï¼Œé‚£ä¹ˆæ— æ³•ç¡®å®šcal å’Œ readçš„æ‰§è¡Œé¡ºåºã€‚
- semaphore åˆå§‹å€¼æ˜¯1ï¼Œå¯èƒ½calå…ˆå¯åŠ¨ï¼Œå¯¼è‡´è®¡ç®—çš„æ¬¡æ•°å°‘äº†1æ¬¡
2. å¦‚æœåœ¨readä¸­åªä½¿ç”¨ post å¢åŠ  semaphoreï¼Œåœ¨calä¸­åªä½¿ç”¨wait å‡å° semaphoreï¼Œæ— æ³•å¯¹ä¸´ç•ŒåŒºè¿›è¡Œä¿æŠ¤
``` cpp
void* read(void *)
{
Â  Â  for(int i=0; i < 5; i++)
Â  Â  {
Â  Â  Â  Â  printf("please input the number:");
Â  Â  Â  Â  scanf("%d", &num);
Â  Â  Â  Â  sem_post(&sem_read);
Â  Â  }
Â  Â  return NULL;
}

void* cal(void *)
{
Â  Â  int sum = 0;
Â  Â  for(int i=0; i < 5; i++)
Â  Â  {
Â  Â  Â  Â  sem_wait(&sem_read);
Â  Â  Â  Â  sum += num;
Â  Â  }
Â  Â  printf("sum = %d\n", sum);
Â  Â  return NULL;
}
```
read å’Œ cal å¯èƒ½åŒæ—¶è®¿é—®num

3. å¦‚æœè¦è®©readä¸€ç›´è¯»å–è¾“å…¥æ»¡5ä¸ªï¼Œè€Œä¸æ˜¯ç­‰calè®¡ç®—ä¸€æ¬¡å†è¯»å–ï¼Œå¯ä»¥ç»“åˆmutexå¯¹ä¸´ç•ŒåŒºä¸Šé”
semaphore ç”¨æ¥æ§åˆ¶è®¿é—®é¡ºåºï¼Œmutexç”¨æ¥ä¿æŠ¤ä¸´ç•ŒåŒº

