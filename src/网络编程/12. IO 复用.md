---
category: 网络编程
---
# 12. I/O 复用

## 12.1 基于I/O 复用的服务器端
**复用的概念**
- “在一个通信频道中传递多个数据（信号）的技术”
- “为了提高物理设备的效率，用最少的物理要素传递最多数据时使用的技术”
- 纸杯电话系统模型：多个纸杯，一条串联起来的连接线

在服务端中的应用：一个服务端进程同时连接多个客户端

复用的特点：
- 不能同时进行通讯，即虽然同时连接了多个客户端，但是需要按顺序逐一处理

## 12.2 理解select函数并实现服务器端
``` cpp
NAME
       select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O multiplexing

SYNOPSIS
       /* According to POSIX.1-2001, POSIX.1-2008 */
       #include <sys/select.h>

       /* According to earlier standards */
       #include <sys/time.h>
       #include <sys/types.h>
       #include <unistd.h>

       int select(int nfds, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *timeout);

       void FD_CLR(int fd, fd_set *set);
       int  FD_ISSET(int fd, fd_set *set);
       void FD_SET(int fd, fd_set *set);
       void FD_ZERO(fd_set *set);
       
	  The time structures involved are defined in <sys/time.h> and look like

	   struct timeval {
		   long    tv_sec;         /* seconds */
		   long    tv_usec;        /* microseconds */
	   };

```


| 参数/函数     | 值   | 用途                                                                                                                                                                                          | 说明                                                                                                                                                                     |
| --------- | --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| readfds   |     | be watched to see if characters become available for reading                                                                                                                                | 在readfds中的文件描述符，被监视是否可读<br>对应于服务端socket是否受到数据                                                                                                                          |
| writefds  |     | be watched to see if space is available for write                                                                                                                                           | 是否可写                                                                                                                                                                   |
| exceptfds |     | be watched  for exceptions.                                                                                                                                                                 | 是否发生异常                                                                                                                                                                 |
| timeout   |     | The timeout argument specifies the interval that select() should block waiting for a file descriptor to become ready.                                                                       | select（）会阻塞，直到以下三种中的任意一种情况发生：<br>*  a file descriptor becomes ready;<br>*  the call is interrupted by a signal handler; or<br>*  the timeout expires.<br>select() 都会返回 |
| nfds      |     | is the highest-numbered file descriptor in any of the three sets, plus 1.                                                                                                                   | 比三种监视的文件描述符中的最大编号fd 大1                                                                                                                                                 |
| FD_CLR    |     | remove a given file descriptor from a set.                                                                                                                                                  |                                                                                                                                                                        |
| FD_ZERO   |     | clears a set.                                                                                                                                                                               |                                                                                                                                                                        |
| FD_SET    |     | add a given file descriptor from a set                                                                                                                                                      |                                                                                                                                                                        |
| FD_ISSET  |     | tests to see if a file descriptor is part of the set;                                                                                                                                       | 判断文件描述符对应的bit位值是否为1，在select（）返回后判断文件描述符是否变化                                                                                                                            |
| tv_sec    |     | 超时时间中的秒数                                                                                                                                                                                    |                                                                                                                                                                        |
| tv_usec   |     | 超时时间中的微秒数                                                                                                                                                                                   |                                                                                                                                                                        |
| RETURN    |     | On success, select() and pselect() return the number of file descriptors contained in the three returned descriptor sets<br>0:  if the timeout expires before anything interesting happens. |                                                                                                                                                                        |

根据select的作用，需要在调用前设置好监视的fd，以及超时时间


### 设置文件按描述符
fd_set 的定义：
``` cpp
/* The fd_set member is required to be an array of longs.  */
typedef long int __fd_mask;

#define __NFDBITS	(8 * (int) sizeof (__fd_mask))

/* Number of descriptors that can fit in an `fd_set'.  */
#define	__FD_SETSIZE		1024

/* fd_set for select and pselect.  */
typedef struct
  {
    /* XPG4.2 requires this member name.  Otherwise avoid the name
       from the global namespace.  */
#ifdef __USE_XOPEN
    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)->fds_bits)
#else
    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)->__fds_bits)
#endif
  } fd_set;
```

fd_set中bit 位序号对应文件描述符，如bit0对应文件描述符0，bit1 对应文件描述符1。如果文件描述符在监视访问内，则对应的bit位的值为1.

**使用宏设置fd_set**

| 代码                            | fd0 | fd1 | fd2 | fd\[0] |
| ----------------------------- | --- | --- | --- | ------ |
| fd_set set;<br>FD_ZERO(&set); | 0   | 0   | 0   | 0      |
| FD_SET(1, &set);              | 0   | 1   | 0   | 1      |
| FD_SET(2, &set);              | 0   | 1   | 1   | 6      |
| FD_CLR(2, &set);              | 0   | 1   | 0   | 2      |

### 设置检查范围及超时
``` cpp
timeval timeout;
timeout.tv_sec = 2;
timeout.tv_usec = 0;
```

### 调用select 函数后查看结果

|       | fd0 | fd1 | fd2 | 说明             |
| ----- | --- | --- | --- | -------------- |
| 初始    | 0   | 1   | 1   | 监视fd1和fd2      |
| 第一次调用 | 0   | 1   | 0   | fd1满足条件，fd2不满足 |
| 第二次调用 | 0   | 0   | 1   | fd2满足条件，fd1不满足 |

>[!info]
>可以认为值仍为1的位置上的文件描述符发生了变化

应该是满足监视条件的的文件描述符对应的fd_set中的bit位值为1.

### 示例
从标准输入读取数据
实现：
``` cpp
int main(int argc, char* argv[])
{
    fd_set set, temp_set;
    FD_ZERO(&set);
    FD_SET(0,&set);

    while(1) {
        temp_set = set;
        timeval timeout;
        timeout.tv_sec = 5;
        timeout.tv_usec = 0;
        int result = select(1, &temp_set, NULL, NULL, &timeout);
        if(result == -1) {
            error_handling("select() error!");
        }
        else if(result == 0) {
            printf("Time-out occurred! No data after 5 seconds.\n");
        }
        else {
            printf("time sec:%d, usec:%d\n", (int)timeout.tv_sec, (int)timeout.tv_usec);
            if(FD_ISSET(0, &temp_set)) {
                char buf[BUF_SIZE];
                fgets(buf, BUF_SIZE, stdin);
                printf("Data received: %s", buf);
            }
        }

    }

    return 0;
}
```

| 行号    | 功能            | 说明                                                                                        |
| ----- | ------------- | ----------------------------------------------------------------------------------------- |
| 3-5   | 设置标准输入为要监视的文件 |                                                                                           |
| 8     | 重置要监视的文件描述符集合 | 因为select（）会修改监视的文件描述符集合，将状态没有变化的文件描述符位置位0，所以每次select（）前均需重置为初始集合                          |
| 8-11  | 设置超时时间        | 每次select（）前均需重新设置，因为调用select（）后timeval 的成员值被替换为超时前剩余时间。如果不修改，那么超时时间会越来越短，导致最后select基本不会等待 |
| 19-26 | 读取stdin数据并打印  |                                                                                           |

效果：
```
ming@ubuntu:/media/sf_share/Network/build$ ./Network
abc
time sec:3, usec:814954
Data received: abc
123
time sec:3, usec:588714
Data received: 123
Time-out occurred! No data after 5 seconds.
```

## 实现 I/O 复用服务器端




