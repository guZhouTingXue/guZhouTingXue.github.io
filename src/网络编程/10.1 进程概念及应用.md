---
category: 进程概念及应用
---
# 10.1 进程概念及应用
>[!info]
>占用内存空间的正在运行的程序

- 占用内存空间：进程是CPU分配内存的基本单位
- 正在运行：程序本身存储在外存（硬盘），运行的程序才会被加载到内存，才算是进程

>[!info]
>CPU的核心（运算设备）和能够同时运行的进程数相同。进程数超过核心数，进程将分时使用CPU资源。

## 进程ID
:::tabs
@tab Linux
``` bash
ming@ubuntu:~$ ps au
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root       704  0.0  0.0  15936  1804 tty1     Ss+  23:53   0:00 /sbin/agetty --noclear tty1 linux
root      1211  0.7  2.2 314956 45796 tty7     Ssl+ 23:53   0:00 /usr/lib/xorg/Xorg -core :0 -seat seat0 -auth /var/run/
ming      1830  0.2  0.2  22636  5108 pts/8    Ss   23:54   0:00 -bash
ming      1848  0.0  0.1  37364  3304 pts/8    R+   23:54   0:00 ps au

```

| 属性      | 含义                       |
| ------- | ------------------------ |
| USER    | 启动进程的用户                  |
| PID     | 进程的ID号 - 区分进程            |
| %CPU    | 占用的CPU使用率（怎么算的？分配的时间占比？） |
| %MEM    | 占用的内存                    |
| VSZ     |                          |
| RSS     |                          |
| TTY     | 从哪个TTY启动的？               |
| STAT    |                          |
| START   | 启动时间                     |
| TIME    | 运行时间                     |
| COMMAND | 程序路径                     |

@tab windows
使用 **Process Explorer** 查看进程状态
下载链接：[Sysinternals - Sysinternals | Microsoft Learn](https://learn.microsoft.com/zh-cn/sysinternals/)
![|700x325](./attachments/10.1%20进程概念及应用.webp)

| 属性            | 含义                           |
| ------------- | ---------------------------- |
| Process       | 进程名称                         |
| CPU           | CPU占用率 或 进程状态？Suspended - 挂起 |
| Private Bytes | 已使用的内存？                      |
| Working Set   | 进程占用的内存？                     |
| PID           | process id                   |
| Description   |                              |
| Company Name  |                              |

:::

## 通过调用fork函数创建进程
在windows 上可以通过双击一个exe来启动进程，在linux可以使用 \./processName 来启动一个可执行文件。编程时使用fork函数创建进程。

``` bash
NAME
       fork - create a child process
SYNOPSIS
       #include <unistd.h>
       pid_t fork(void);
```
新创建的进程是原进程的子进程。调用fork后父子进程拥有相同的 memory spaces，但是之后的操作是独立执行的，互不影响。

**测试fork**
``` cpp 
int main(int argc, char* argv[])
{
    int i = 3;
    pid_t pid;
    pid = fork();
    if(pid == -1)
        unix_error("fork error");
    else if(pid == 0) { // child process
        i += 2;
        printf("Child Process: i = %d\n", i);
    } else { // parent process
        i -= 1;
        printf("Parent Process: i = %d\n", i);
    }
    return 0;
}
```

| 行号    | 功能     | 说明                                     |
| ----- | ------ | -------------------------------------- |
| 5     | 创建子进程  |                                        |
| 6、7   | 创建出错处理 |                                        |
| 8-10  | 子进程处理  | 通过放回的pid_t 区分父子进程，成功创建子进程后子进程中的pid_t为0 |
| 11-13 | 父进程处理  | 父进程中放回的pid_t 是子进程的pid                  |
效果：
![|403x73](./attachments/10.1%20进程概念及应用-1.webp)
创建子进程后父子进程中的i都是3，父进程对i减1，所以父进程的i为2。子进程对i加2，所以子进程中的i为5。
父进程已经结束了（打印了提示命令提示信息），然后再执行子进程打印


