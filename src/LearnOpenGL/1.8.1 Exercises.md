---
category: LearnOpenGL
---
# 1.8.1 Exercises
**1**
>Try experimenting with the FoV and aspect-ratio parameters of GLM's projection function. See if you can figure out how those affect the perspective frustum.

**2**
>Play with the view matrix by translating in several directions and see how the scene changes. Think of the view matrix as a camera object.

**3**
>Try to make every 3rd container (including the 1st) rotate over time, while leaving the other containers static using just the model matrix


## 1
[WebGL Example](https://learnwebgl.brown37.net/08_projections/create_perspective/create_perspective.html)
用上面网站进行测试
### FoV
aspect: 1.0 (width/height)
near: 1.0
far: 10.0

:::tabs
@tab Fov = 5
![|400x265](./attachments/1.8.1%20Exercises-4.webp)
@tab Fov = 45
![|399x263](./attachments/1.8.1%20Exercises.webp)
@tab Fov = 90
![|401x266](./attachments/1.8.1%20Exercises-1.webp)
@tab Fov = 135
![|402x267](./attachments/1.8.1%20Exercises-2.webp)
@tab Fov = 179
![|398x264](./attachments/1.8.1%20Exercises-3.webp)
:::

Fov从5增加到179的过程中视野逐渐增大，物体越来越小，离镜头（观察点/camera）越来越远。
### aspect-ratio
:::tabs
@tab aspect = 0.1
![|400x264](./attachments/1.8.1%20Exercises-5.webp)
@tab aspect = 1.0
![|401x268](./attachments/1.8.1%20Exercises-6.webp)
@tab aspect = 2.0
![|401x266](./attachments/1.8.1%20Exercises-7.webp)
@tab aspect = 5.0
![|399x263](./attachments/1.8.1%20Exercises-8.webp)
:::

aspect 从0.1 增加到5.0的过程中，高度保持不变，宽度逐渐增加。积木离镜头的距离保持不变，但是积木的形状由拉伸变换为压缩



## 2
把view matrix 视作camera object，调整camera 的位置，观察不同位置下呈现的图像效果。
实现：
``` cpp
        glm::mat4 view = glm::mat4(1.0f);
        view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
        view = glm::rotate(view, glm::radians(-45.0f), glm::vec3(0.0f, 1.0f, 0.0f));
```

把camera 绕y轴 向右（顺时针-正）转动45°，相当于把world space 向左（逆时针-负）转动45°
效果：

:::tabs
@tab camera右转动45°
![|399x318](./attachments/1.8.1%20Exercises-9.webp)
@tab 右60°
![|400x319](./attachments/1.8.1%20Exercises-10.webp)
@tab 右75°
![|398x317](./attachments/1.8.1%20Exercises-11.webp)

:::


### 3
只让序号为3的倍数的cube 旋转，其余保持静止
:::tabs
@tab 参考
``` cpp
    glm::mat4 model = glm::mat4(1.0f);
    model = glm::translate(model, cubePositions[i]);
    float angle = 20.0f * i; 
    if(i % 3 == 0)  // every 3rd iteration (including the first) we set the angle using GLFW's time function.
        angle = glfwGetTime() * 25.0f;
    model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
```
@tab 我的
``` cpp
          glm::mat4 model = glm::mat4(1.0f);
            model = glm::translate(model, cubePositions[i]);
            if(i % 3 == 0)
            {
                float angle = 20.0f * i;
                model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
            }
```
:::

效果：
![|401x319](./attachments/1.8.1%20Exercises-12.webp)

第一个container 没有旋转是因为i 为0-》转动的角度为0°
