---
category: LearnOpenGL
---
# 1.9 Camera


## Camera/View space
通过view matrix 将 world space 转换为 view space
现在尝试通过定义camera 的位置（position） 和 camera的朝向-镜头看向哪个方向（direction）来获取对应的view matrix
示例图
![](./attachments/1.9%20Camera.webp)

1. camera 的position：（0，0，2）view coordinate system的origin
2. 这里camera 看向原点？和图中camera z轴正方向相反？定义view coordinate system z轴方向
3. 利用单位向量（0，1，0），确定view coordinate system的x轴
4. 根据x、z确定y轴

### 1. Camera position
>[!info]
>The camera position is a vector in world space that points to the camera's position.

``` cpp
glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);
```
camera朝屏幕屏幕内移动（z轴负方向），这space 朝着屏幕外移动（z轴正方向）。
### 2. Camera direction
并没有直接给出表示camera 镜头朝向的向量，而是通过camera 观察具体的点的坐标以及camera 的position 间接确认camera direction。

示例中的代码和前面图示不一致，不好
假设camera 看向 （0，0，0），这个点也可以用一个从原点出发指向看向点的向量表示.
``` cpp
glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);
```
那么camera direction 可以通过向量的减法计算得出：
``` cpp
glm::vec3 cameraDirection_0 = glm::normalize(cameraTarget - cameraPos);
```
从camera 出发，指向被减向量，并且转换为单位向量。

>[!info]
>the camera points towards the negative z-axis 

实际的z轴正方向和camera 的朝向相反，所以需要反转下计算得到的direction
``` cpp
glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);
```


### 3. Right axis
camera coordinate system 只要满足camera的postion 以及 direction 以及 是正交的就可以了。至于x、y的方向不影响camera 观察space，所以无关紧要。
>[!warning]
>以上仅代表我个人的理解

假设（0，1，0）在 y、z平面上，通过cross product 可以得到Right axis 
``` cpp
glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);
glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));
```

### 4. Up axis
已知x、z 再次通过cross product得到 Up axis
``` cpp
glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);
```

现在通过camera 的position 以及 direction 可以创建处 camera coordinate system了

## Look at
$$
LookAt = \begin{bmatrix} \color{red}{R_x} & \color{red}{R_y} & \color{red}{R_z} & 0 \\ \color{green}{U_x} & \color{green}{U_y} & \color{green}{U_z} & 0 \\ \color{blue}{D_x} & \color{blue}{D_y} & \color{blue}{D_z} & 0 \\ 0 & 0 & 0  & 1 \end{bmatrix} * \begin{bmatrix} 1 & 0 & 0 & -\color{purple}{P_x} \\ 0 & 1 & 0 & -\color{purple}{P_y} \\ 0 & 0 & 1 & -\color{purple}{P_z} \\ 0 & 0 & 0  & 1 \end{bmatrix}
$$
$R_x \space R_y \space R_z$ ：right vector 的三个坐标分量
$U_x \space U_y \space U_z$ ：up vector 的三个坐标分量
$D_x \space D_y \space D_z$ ：direction vector 的三个坐标分量
$P_x \space P_y \space P_z$ ：camera position 的三个坐标分量

左侧的rotation matrix 是倒置的（因为需要调换z轴方向）。如果camera就在原点，调转camera的朝向，相当于rotation axis。
右侧的transform matrix 取反（因为实际移动方向相反）

>[!info]
>Using the LookAt matrix effectively transforms all the world coordinates to the view space we just defined.

**通过glm创建Look at matrix**
``` cpp
glm::mat4 view;
view = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), 
  		   glm::vec3(0.0f, 0.0f, 0.0f), 
  		   glm::vec3(0.0f, 1.0f, 0.0f));
  		   
glm::mat4 glm::lookAt(glm::vec3 const& eye, glm::vec3 const& center, glm::vec3
const& up);
```

| 参数     | 值   | 用途        | 说明  |
| ------ | --- | --------- | --- |
| eye    |     | position  |     |
| center |     | target    |     |
| up     |     | up vector |     |

... 参数的名称为什么和我想的不太一样，第一个参数应该叫center-camera的中心位置，第二个参数不应该叫eye吗？

分别看向4个方向 1.0的位置
:::tabs
@tab 上
![|400x319](./attachments/1.9%20Camera-1.webp)
@tab 下
![|399x318](./attachments/1.9%20Camera-2.webp)
@tab 左
![|400x319](./attachments/1.9%20Camera-3.webp)
@tab 右
![|402x320](./attachments/1.9%20Camera-4.webp)
:::


绕原点旋转
``` cpp
const float radius = 10.0f;
float camX = sin(glfwGetTime()) * radius;
float camZ = cos(glfwGetTime()) * radius;
glm::mat4 view;
view = glm::lookAt(glm::vec3(camX, 0.0, camZ), glm::vec3(0.0, 0.0, 0.0), glm::vec3(0.0, 1.0, 0.0));
```

效果：
![|401x319](attachments/1_9_Camera_LookAt.gif)


## Walk around
**目的：** 通过按键调整camera的位置（前进、后退、左移 和 右移）
1. 定义camear的初始位置相关参数，创建LookAt matrix
``` cpp
glm::vec3 cameraPos   = glm::vec3(0.0f, 0.0f,  3.0f);
glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);
glm::vec3 cameraUp    = glm::vec3(0.0f, 1.0f,  0.0f);

view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
```

| 行号  | 功能             | 说明                                                                         |
| --- | -------------- | -------------------------------------------------------------------------- |
| 2   | 定义从camera出发的朝向 |                                                                            |
| 5   |                | 看向的点是在cameraPos的基础上向着cameraFront的方向，这里cameraFront 指向z轴负方向，所以camera看向z轴负方向  |

2. 按键处理，更新camera的position
``` cpp

void processInput(GLFWwindow *window)
{
    ...
    const float cameraSpeed = 0.05f; // adjust accordingly
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
        cameraPos += cameraSpeed * cameraFront;
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
        cameraPos -= cameraSpeed * cameraFront;
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
}
```

| 行号  | 功能         | 说明                                                    |
| --- | ---------- | ----------------------------------------------------- |
| 5   | 定义移动的速度    | 在render loop 处理按键输入，处理的次数由运行程序的cpu处理性能决定。需要实时调整       |
| 7   | 向前移动camera | 朝着camera朝向移动，cameraFront-朝向，单位向量；speed-每次移动的距离        |
| 11  | 向左移动camera | 先获取camera coordinate system 的 x-axis 方向上的单位向量，然后减去移动值 |

效果：
![|500x330](attachments/1_9_Camera_Walk_around.gif)
