---
category: LearnOpenGL
---
# 1.4.1 Exercises

**1. Try to draw 2 triangles next to each other using glDrawArrays by adding more vertices to your data**

**2. Now create the same 2 triangles using two different VAOs and VBOs for their data**

**3. Create two shader programs where the second program uses a different fragment shader that outputs the color yellow; draw both triangles again where one outputs the color yellow**

## 1
目标：绘制如下图所示的两个三角形
![|377x300](./attachments/1.4.1%20Exercises.webp)
实现：
``` cpp
    float vertices[] = {
        -0.8f, -0.6f, 0.0f,
        -0.4f, 0.6f, 0.0f,
        0.0f, -0.6f, 0.0f,
        0.4f, 0.6f, 0.0f,
        0.8f, -0.6f, 0.0f
    };
    unsigned int indices[] = {  // note that we start from 0!
        0, 1, 2,   // first triangle
        2, 3, 4    // second triangle
    };
    
    // ..:: Drawing code (in render loop) :: ..
	glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

```

效果：
![|397x316](./attachments/1.4.1%20Exercises-1.webp)
不考虑比例关系，显示正确。

## 2
目标：使用两个VOA 和 VBO 来绘制上面的两个三角形
实现：
``` cpp
    float vertices[] = {
        -0.8f, -0.6f, 0.0f,
        -0.4f, 0.6f, 0.0f,
        0.0f, -0.6f, 0.0f
    };

    float vertices2[] = {
        0.0f, -0.6f, 0.0f,
        0.4f, 0.6f, 0.0f,
        0.8f, -0.6f, 0.0f
    };

    unsigned int VBO;
    glGenBuffers(1, &VBO);

    unsigned int VAO;
    glGenVertexArrays(1, &VAO);

    unsigned int VBO2;
    glGenBuffers(1, &VBO2);

    unsigned int VAO2;
    glGenVertexArrays(1, &VAO2);

    // 1. bind Vertex Array Object
    glBindVertexArray(VAO);
    // 2. copy our vertices array in a buffer for OpenGL to use
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    // 3. then set our vertex attributes pointers
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    glBindVertexArray(VAO2);
    glBindBuffer(GL_ARRAY_BUFFER, VBO2);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices2), vertices2, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    
	// ..:: Drawing code (in render loop) :: ..
	glUseProgram(shaderProgram);
	glBindVertexArray(VAO); // seeing as we only have a single VAO there's no need to bind it every time, but we'll do so to keep things a bit more organized
	glDrawArrays(GL_TRIANGLES, 0, 3);

	glBindVertexArray(VAO2);
	glDrawArrays(GL_TRIANGLES, 0, 3);
```

效果：
![|400x318](./attachments/1.4.1%20Exercises-2.webp)


## 3
目标：使用不同的program 显示不同的颜色
![|401x319](./attachments/1.4.1%20Exercises-3.webp)
vertex 的处理相同，fragment 输出的颜色不同
黄色的颜色值：rgb01(1, 0.984, 0)
实现：
``` cpp
const char *fragmentShaderSource2 = //"as before ..."
                                   "   FragColor = vec4(1.0f, 0.984f, 0.0f, 1.0f);\n"
                                   "}\n\0";
                                   
    //program2
    unsigned int fragmentShader2;
    fragmentShader2 = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader2, 1, &fragmentShaderSource2, NULL);
    glCompileShader(fragmentShader2);
	//省略了错误检查
    unsigned int shaderProgram2;
    shaderProgram2 = glCreateProgram();
    glAttachShader(shaderProgram2, vertexShader); //[!code highlight]
    glAttachShader(shaderProgram2, fragmentShader2); //[!code highlight]
    glLinkProgram(shaderProgram2);

    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);
    glDeleteShader(fragmentShader2);           
    
	// ..:: Drawing code (in render loop) :: ..
	glUseProgram(shaderProgram);
	glBindVertexArray(VAO); 
	glDrawArrays(GL_TRIANGLES, 0, 3);

	glUseProgram(shaderProgram2);
	glBindVertexArray(VAO2);
	glDrawArrays(GL_TRIANGLES, 0, 3);                 
```

效果：
![|400x319](./attachments/1.4.1%20Exercises-4.webp)
