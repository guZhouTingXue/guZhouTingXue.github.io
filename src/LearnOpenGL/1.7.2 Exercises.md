---
category: LearnOpenGL
---
# 1.7.2 Exercises
**1**
>Using the last transformation on the container, try switching the order around by first rotating and then translating. See what happens and try to reason why this happens

>[!note]
>这里题目应该是搞反了，示例中的代码是先旋转后移动，所以练习中调换顺序的话应该是先移动后旋转

**2**
>Try drawing a second container with another call to glDrawElements but place it at a different position using transformations only. Make sure this second container is placed at the top-left of the window and instead of rotating, scale it over time (using the sin function is useful here; note that using sin will cause the object to invert as soon as a negative scale is applied)

![|401x319](attachments/1_7_2_Transformations_Exercise2.gif)
## 1
调换变换的顺序，先旋转后移位
实现：
``` cpp
	glm::mat4 trans(1.0f);
	trans = glm::rotate(trans, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f));
	trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));
```
效果：
![|399x318](attachments/1_7_2_Transformations_Exercise1.gif)

可以看到笑脸是绕着原点在进行旋转而不是自身的中心点


## 2
再绘制一个container，然后应用不同的变换（移动到左上角，动态放大或缩小）
两个container除了trans 不一样，其余的均相同。

:::tabs
@tab 参考答案
``` cpp
        // second transformation
        // ---------------------
        transform = glm::mat4(1.0f); // reset it to identity matrix
        transform = glm::translate(transform, glm::vec3(-0.5f, 0.5f, 0.0f));
        float scaleAmount = static_cast<float>(sin(glfwGetTime()));
        transform = glm::scale(transform, glm::vec3(scaleAmount, scaleAmount, scaleAmount));
        glUniformMatrix4fv(transformLoc, 1, GL_FALSE, &transform[0][0]); // this time take the matrix value array's first element as its memory pointer value

        // now with the uniform matrix being replaced with new transformations, draw it again.
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
```
- 仍然使用trans，重新对其进行赋值
- 数组首元素的地址：&transform - 数组名； &transform\[0]\[0] -对数组首元素取地址

@tab 我的实现
``` cpp
while(!glfwWindowShouldClose(window))
{
	//...
	glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

	glm::mat4 trans2(1.0f);
	trans2 = glm::translate(trans2, glm::vec3(-0.5f, 0.5f, 0.0f));
	auto s = sin((float)glfwGetTime());
	trans2 = glm::scale(trans2, glm::vec3(s, s, 0.0f));
	glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans2));

	glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
}
```

| 行号  | 功能                  | 说明  |
| --- | ------------------- | --- |
| 4   | 绘制第一个container      |     |
| 6-9 | 创建第二个container的变换矩阵 |     |

:::

如果先进行translate，那么scale的效果会作用到translate上，移动的距离也跟着放大或缩小 以及反向。效果如下：
![|399x318](attachments/1_7_2_Transformations_Exercise2_1.gif)

矩阵乘法的特性-后面的变换会影响前面的变换 和 万向节的物理特性（外环可以带动内环转，但是内环不能带动外环转）一致。
