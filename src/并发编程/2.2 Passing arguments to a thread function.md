---
category: 并发编程
---
# 2.2 Passing arguments to a thread function
>[!quote]
>It's important to bear in mind that by default, the arguments are copied into internal storage, where they can be accessed by the newly created thread of execution, and then passed to the callable object or function as rvalues as if they were temporaries.

- copied into internal storage
- rvalues
## 在thread的构造函数中传递参数
使用：
``` cpp
void f(int i, std::string const &s)
{
    std::cout << "i:" << i << " s:" << s << std::endl;
}
int main()
{
    std::thread t(f, 3, "hello");
    t.join();

	return 0;
}
```


| 行号  | 功能                      | 说明                      |
| --- | ----------------------- | ----------------------- |
| 1-4 | 线程执行的function定义         | 函数具有两个参数，第二个参数类型为const& |
| 7   | 创建线程并传递参数给线程执行的function | 参数跟在函数参数f后，按照顺序传递给f     |

效果：
``` 
i:3 s:hello
```

## 参数传递的过程
参数先copied into 到 thread 的internal storage，调用function 时再以右值类型传递给function。
创建MyClass 类，在类的拷贝构造、赋值，移动构造、赋值函数中增加打印，然后function 接收MyClass类对象作为参数，观察类对象的创建过程。
实现：
``` cpp
struct MyClass{
    MyClass(){
        cout << "MyClass()" << endl;
    }
    MyClass(const MyClass&){
        cout << "MyClass(const MyClass&)" << endl;
    }
	//略
    ~MyClass(){
        cout << "~MyClass" << endl;
    }
};
void fc(MyClass f)
{
    cout << "fc(MyClass)" << endl;
}
int main()
{
    MyClass mc;
    cout << __LINE__ << endl;
    std::thread t1(fc, mc);
    cout << __LINE__ << endl;
    t1.join();

	return 0;
}
```

效果：
``` 
MyClass()
44
MyClass(const MyClass&)
46
MyClass(MyClass&&)
fc(MyClass)
~MyClass
~MyClass
~MyClass
```

| 行号/打印内容                    | 说明                                                 |
| -------------------------- | -------------------------------------------------- |
| 1/MyClass                  | 构造mc                                               |
| 3/MyClass(const MyClass &) | 将mc copied into internal storage                   |
| 5/MyClass(Myclass&&)       | 线程启动，调用fc。 传递thread internal storage 中的临时对象（右值）给fc |
| 6/fc(MyClass)              | 执行fc                                               |
同样地，对于前面的thread t 传递参数"hello" 给 f，先是拷贝"hello" 到 internal storage，其类型为const char \*， 然后线程调用 f(3， "hello")

## 传递指针参数
>[!quote]
>This is particularly important when the arguments supplied is a pointer to an automatic variable

如果传递指针类型参数，且指针指向的是automatic variable（局部临时变量），在调用function前，指针指向的变量可能已经销毁。
实现：
``` cpp
void not_oops(int some_param, char **address)
{
    char buffer[8];
    *address = buffer;
    cout << "buffer address:" << (void*)(&buffer) << endl;

    sprintf(buffer, "%i", some_param);
    std::thread t(f, 3, buffer);
    t.detach();
}


int main()
{
    char *address;
    not_oops(3, &address);
    cout << "address:" << (void*)(address) << " v:" << std::string(address) << endl;
    while(1)
        ;

	return 0;
}

```

| 行号    | 功能                   | 说明                                       |
| ----- | -------------------- | ---------------------------------------- |
| 3     | 创建指针                 |                                          |
| 4     | 将buffer的地址赋值给address |                                          |
| 8     | 创建线程，传递指针参数          | thread中的临时变量类型为char* ，指向oops中的buffer     |
| 9     | 分离线程                 | 函数返回（退出）后automatic variable buffer 会自动销毁 |
| 18、19 | 等待子线程执行完毕            |                                          |

效果：
``` 
buffer address:0xfc757ffc54
address:0xfc757ffc54 v:
i:3 s:
```
s输出内容随机
先打印 addres：。。。说明执行f（3，buffer）前，not_oops()已经返回（buffer 已经销毁）。在执行f（）时buffer指向的内容已经发生变化。如果f（）在not_oops()之前执行那么应打印 i:3 s:3

延时（sleep）让f（）先执行完毕
输出：
``` 
buffer address:0x7c6cdffaa4
i:3 s:3
address:0x7c6cdffaa4 v:
```

### 避免implicit conversion
如果传递的实参类型和执行的线程函数参数类型不一致，应该在创建thread 对象时进行类型转换，而不是等到线程启动前的implicit conversion

显式转换类型：
``` cpp
std::thread t(f, 3, std::string(buffer));
```
输出：
``` cpp
buffer address:0xab225ffa28
address:0xab225ffa28 v:
i:3 s:3
```
	
