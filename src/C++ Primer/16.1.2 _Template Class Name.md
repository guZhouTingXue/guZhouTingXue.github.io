---
category: C++Primer
---

# Template Class name
两种情况下使用 template class name：
- inside Class Code
- outside the Class Template Body
<!-- more -->

> [!quote]
> Inside the scope of the class template itself, we may use the name of the template without arguments.

BlobPtr 是用于访问Blob存储的数据的类型
``` cpp
template <typename T>
class BlobPtr {
public:
    BlobPtr() : curr(0) {}
    BlobPtr& operator++();

    BlobPtr operator++(int);
private:
    std::weak_ptr<std::vector<T> > wptr;
    std::size_t curr;
};
```
在类内，可以直接使用BlobPtr，而不是BlobPtr\<T>。
即使是其引用，使用BlobPtr& 而不是 BlobPtr\<T> &

## 类外访问
在类外定义后置自增运算函数
``` cpp
template <typename T>
BlobPtr<T>
BlobPtr<T>::operator++(int) {
    BlobPtr ret = *this;
    ++*this;
    return ret;
}
```

| 行号  | 功能                 | 说明                                                                              |
| --- | ------------------ | ------------------------------------------------------------------------------- |
| 3   | 后置自增函数             | 通过是否带参数区分是prefix 还是 postfix operator                                            |
| 4   | 定义BlobPtr对象        | 在出现BlobPtr\<T>：：后就进入了class scope（包括参数列表和函数体），在scope内使用BlobPtr 相当于使用 BlobPtr\<T> |
| 5   | 使用prefix increment | \*this 返回BlobPtr &，++(\*this) 调用operator++()                                    |
| 3   | 返回类型需要带模板参数        | 返回类型在名称作用域前（不在scope内），所以需要提供模板参数                                                |
